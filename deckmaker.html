
<!DOCTYPE html>

<html lang="ja">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google-site-verification" content="5NzYWNH5_YUg0dUV2iCzg_bSo7M1lLJi6IzOeF2dGXM" />
    <!-- ページの説明（検索結果の下に表示） -->
    <meta name="description" content="このサイトは、アプリ「信託のメソロギア」のカード一覧、デッキ構築、デッキ分析ができる非公式サイトです。カード検索やデッキ管理をスマホでも快適に！">
    <!-- キーワード（今は効果は薄いが一応） -->
    <meta name="keywords" content="カードゲーム,デッキメーカー,DCG,神託のメソロギア,メソロギア,神託,デッキ分析,一覧,モスロギア">
    <!-- OGP基本 -->
    <meta property="og:title" content="モスロギア | 神託のメソロギア デッキメーカー">
    <meta property="og:description" content="このサイトはアプリ「神託のメソロギア」のカード検索・デッキ構築ができる非公式サイトです。">
    <meta property="og:image" content="https://mosurogia.github.io/mesorogia-cards/img/deckmakerogp.webp">
    <meta property="og:url" content="https://mosurogia.github.io/mesorogia-cards/">
    <meta property="og:type" content="website">

    <!-- Twitterカード向け -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="モスロギア | 神託のメソロギア デッキメーカー">
    <meta name="twitter:description" content="カード検索とデッキ構築で信託のメソロギアをもっと楽しもう！">
    <meta name="twitter:image" content="https://mosurogia.github.io/mesorogia-cards/img/deckmakerogp.webp">

    <meta charset="utf-8" />
    <title>モスロギア 神託のメソロギア デッキメーカー</title>
<link href="favicon.ico" rel="icon" type="image/png"/>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
<style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #f5f5f5;
    }

    .main-header {
  height: 55px;
  background-image: url("img/header.webp");
  background-repeat: repeat-x;       /* 横方向に繰り返し */
  background-size: auto 55px;        /* 高さ55pxにフィット */
  background-position: center center;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0px 5px;
  color: white;
  top: 0;
  z-index: 1000;
}

.header-logo img {
  height: 1.8em;
  width: auto;
  margin-top: 10px;
  object-fit: contain;
}

.header-nav a {
  margin-left: 1em;
  color: white;
  text-decoration: none;
  font-weight: bold;
  font-size: 0.85em;
  background-color: rgba(0, 0, 0, 0.4);
  padding: 6px 0.2em;
  border-radius: 6px;
  transition: background-color 0.3s;
}

.header-nav a:hover {
  background-color: rgba(255, 255, 255, 0.2);  /* 軽いホバー効果 */
  text-decoration: none;
}

    .tab-bar {
      display: flex;
      background: #333;
      color: white;
    }
    .tab {

      flex: 1;
      padding: 10px 2vw;
      text-align: center;
      cursor: pointer;
      border-bottom: 3px solid transparent;
    }
    .tab span {
      background: rgba(0, 0, 0, 0.4); /* 背景の黒半透明 */
      border-radius: 6px;
      display: inline-block;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      font-size: clamp(17px, 4.5vw, 35px);
    }
.tab:not(.active):hover span {
  background-color: rgba(255, 230, 150, 0.6);  /* 明るめに変化 */
  transition: background 0.3s;
}

    .tab.active {
      border-bottom: 3px solid yellow;
      background: #444;
    }
    .tab-content {
      display: none;
      padding: 8px;
    }
    .tab-content.active {
      display: block;
    }
#tab1 {
  background-image: url("img/tab1.2.webp");
  background-size: cover;
  background-position: center;
  color: white;
  text-shadow: 1px 1px 2px black;
}

#tab2 {
  background-image: url("img/tab2.webp");
  background-size: cover;
  background-position: center;
  color: white;
  text-shadow: 1px 1px 2px black;
}
    .fixed-top-bar{
      position: sticky;
      top: 0px;
      background: #fff;
      z-index: 100;
      border-bottom: 1px solid #ccc;
    }
    .search-bar{
      position: sticky;
      top: 0px;
      background: #fff;
      z-index: 100;
      display: flex;
      gap: 1rem;
      padding: 8px;
      border-bottom: 1px solid #ccc;
    }
    .search-bar input {
      flex: 1;
      padding: 0.5rem;
      font-size: 1rem;
      box-sizing: border-box;
    }
    select{
      font-size: 0.8rem;
    }
    #sort-select{
      max-width: 100px;
      font-size: clamp(5px, 3vw, 18px);
    }
    .deck-card {
      width: 100px;
      background: #ccc;
      border: 2px solid #666;
      position: relative;
      flex-shrink: 0;
      box-sizing: border-box;
      border-radius: 6px;
      z-index: 2000; /* ← sticky header より大きく！ */
    }
    .deck-card img {
      width: 100%;
      display: block;
    }
    .count-badge {
      position: absolute;
      top: 2px;
      right: 4px;
      background: #222;
      color: #fff;
      font-size: 15px;
      border-radius: 20px;
      padding: 1px 8px;
    }




.deck-bar-wrapper {
  display: flex;
  overflow: hidden;
}
.deck-bar-scroll {
  position: relative;
  overflow-x: auto;
  overflow-y: hidden;
  touch-action: pan-x;
  flex: 1;
}

#deckHelp {
  white-space: nowrap;
  font-size: 0.6rem;
  display: flex;
  color: #555;
  padding: 4px;
  border-radius: 6px;
  gap: 8px;
}

.deck-bar-top {
  min-height: 80px;
  display: flex;
  gap:  4px;
  padding: 4px 4px 0px 4px;
  background: #fff;
  flex-wrap: nowrap;
  align-items: flex-start;
}

.deck-bar-content {
  overflow: visible;  /* ← transform の飛び出しを切らない！ */
  position: relative;
}

.deck-summary {
  width: 155px;
  text-align: right;
  font-size: 14px;
  line-height: 1.4;
  background: #fff;
  border-left: 1px solid #ccc;
  padding: 4px;
  flex-shrink: 0; /* 🔑 固定幅として右に居座る */
  z-index: 2001;
}
.deck-summary-toggle {
    display: none;
  }

.analyze-button-wrapper {
  margin-top: 0.3rem;
  text-align: center;
}

.analyze-button {
  background-color: #6a5acd;
  color: white;
  font-size: 0.6rem;
  padding: 6px 14px;
  border: none;
  border-radius: 16px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.analyze-button:hover {
  background-color: #5a4cb5;
}

input[type="text"] {
  font-size: 16px;
  padding: 6px 12px;
  height: 36px;
}
    .grid {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
    .card {
      width: calc(100% / 7 - 5px);
      box-sizing: border-box;
      cursor: pointer;
      position: relative;
    }
    .card img {
      width: 100%;     /* グリッドセルの幅に合わせる */
      height: auto;    /* アスペクト比を維持 */
      display: block;  /* 余白をなくす */
      border-radius: 6px;
    }

    button, .card {
  touch-action: manipulation;
}
.card.grayscale img {
  filter: grayscale(100%);
  opacity: 0.5;
}
.hidden-by-grayscale {
  display: none !important;
}
    .zoom-btn {
      position: absolute;
      bottom: 4px;
      left: 4px;
      background: rgba(0,0,0,0.6);
      color: white;
      font-size: 16px;
      border-radius: 4px;
      padding: 2px 6px;
      cursor: pointer;
  z-index: 10;
  pointer-events: auto;

}

    .card.grayscale .zoom-btn {
  pointer-events: auto; /* ← 🔎を有効に */
  z-index: 10;
  pointer-events: auto;

}

    .modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1200;
  justify-content: center;
  align-items: center;
}

.modal-content {
  background: #fff;
  padding: 20px;
  border-radius: 10px;
  max-width: 950px;
  width: 90%;
  max-height: 100%;
  overflow-y: auto;
  position: relative;
  box-sizing: border-box;
  margin: auto;

}
.filter-btn {
  margin: 4px 0px;
}

    .filter-btn.selected {
      background-color: #333;
      color: white;
    }
    .filter-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    #extra-conditions{
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    }
#filterModal {
  display: none;
  flex-direction: column;
  max-height: 120vh;
  overflow-y: auto;
}
#scrollTopFixed {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 40px;
  aspect-ratio: 1/1;
  padding: 0;
  font-size: 25px;
  background-color: #eee;
  border-radius: 50%;
  border: 1px solid #aaa;
  cursor: pointer;
  z-index: 9999;
}
/* カード詳細の基本スタイル */
.card-detail {
  display: none;
  width: 100%;
  padding: 1rem;
  border-radius: 6px;
  margin: 0.5rem 0;
  box-sizing: border-box;
}

/* ===== タイプ別背景色 ===== */
.type-アタッカー {
  background: rgba(125, 91, 155, 0.5);  /* 紫 */
}
.type-チャージャー {
  background: rgba(119, 170, 212, 0.5);  /* 水色 */
}
.type-ブロッカー {
  background: rgba(214, 212, 204, 0.5);  /* 灰色 */
}

/* ===== 種族別枠線色 ===== */
.race-ドラゴン {
  border: 6px solid rgb(200, 40, 40);
}
.race-アンドロイド {
  border: 6px solid rgb(40, 200, 200);
}
.race-エレメンタル {
  border: 6px solid rgb(40, 180, 90);
}
.race-ルミナス {
  border: 6px solid rgb(240, 200, 40);
}
.race-シェイド {
  border: 6px solid rgb(150, 100, 180);
}
.race-イノセント {
  border: 6px solid silver;
}
.race-旧神 {
  border: 6px solid;
  border-image: linear-gradient(
    90deg,
    rgba(255, 255, 255, 0.6),
    rgba(255, 215, 140, 0.8),
    rgba(180, 255, 255, 0.7),
    rgba(220, 180, 255, 0.7),
    rgba(255, 255, 255, 0.6)
  ) 1;
}

/* ===== 補足表示用 ===== */
.card-name {
  font-weight: bold;
  font-size: 1.1em;
  margin-bottom: 0.3em;
}

.card-meta {
  font-size: 0.9em;
  color: #333;
  margin-bottom: 0.5em;
}

.card-effect {
  font-size: 0.95em;
  line-height: 1.5;
}

.deck-filter-bar {
  display: flex;
  justify-content: center;
  align-items: center;
}

.filter-toggle-button {
  width: 100%;
  background-color: #e0e0e0;
  color: #333;
  font-size: 0.5rem;
  padding: 2px 0px;
  border: 1px solid #aaa;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.filter-toggle-button.active {
  background-color: #6a5acd;
  color: white;
  border-color: #5a4cb5;
}

.used-label {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.6);
  color: white;
  font-weight: bold;
  font-size: 0.85em;
  text-align: center;
  z-index: 5;
}

#deck-layout {
  display: flex;
  flex-direction: column;
  gap: 0.2rem;
}

.deck-section {
  background: #fff;
  padding: 0.5rem 0px;
  border: 1px solid #ccc;
  border-radius: 6px;
  max-height: 25rem;

}

#deck-card-list {
  position: relative;
  background-image: url("img/cardlist.webp");
  background-repeat: no-repeat;
  background-size: cover;
  background-position: center;
  display: grid;
  grid-template-columns: repeat(5, 1fr); /* 横5列 */
  gap: 4px; /* カード間の隙間 */
  padding: 8px;
  min-height: 140px;
  align-content: start;       /* カードを上詰め配置 */
  justify-content: start;
  overflow-y: auto;
}
#deckcard-empty-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  opacity: 0.8;
  text-shadow: 1px 1px 2px #000;
  text-align: center;
  pointer-events: none;
  z-index: 1;
}
#deck-info{
  overflow-y: auto;
}

.deck-entry {
  position: relative;
  width: 100%;
  box-sizing: border-box;
  cursor: pointer;
}

.deck-entry img {
  width: 100%;
  height: auto;
  display: block;
  border-radius: 6px;
}
/* 代表カードの枠（styleタグまたはCSSに追加） */
.deck-entry.representative {
  outline: 3px solid crimson;
  outline-offset: -2px;
  border-radius: 6px;
  box-shadow: 0 0 10px limegreen;
}

#analysis-section {
  max-height: 0;
  opacity: 0;
  transition: max-height 0.5s ease, opacity 0.5s ease;
}

#analysis-section.open {
  max-height: 700px; /* 必要に応じて調整 */
  opacity: 1;
}
#deck-info .deck-name-row {
  margin-bottom: 0.5rem;

}
#deck-info label {
  font-weight: bold;
  margin-right: 0.5rem;
}
#deck-info input[type="text"] {
  width: 100%;
  max-width: 240px;
  padding: 4px 8px;
  font-size: 0.65rem;
  box-sizing: border-box;
}
#deck-info div {
  font-size: 0.65rem;
  overflow-y: auto;
}
#exchange-toggle-btn{
  font-size: 0.65em;
}
#toggle-analysis-btn{
  font-size: 0.6em;
}
.deck-code-controls button{
  font-size: 0.85em;
}
.deck-type-breakdown {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem 1rem; /* 行と列に少し余白 */
  font-size: 0.9rem;
}

.deck-type-breakdown .type-count {
  white-space: nowrap; /* タイプごとに折り返しを防ぐ */
}
#savedDeckList {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); /* ⬅ 2列対応 */
  gap: 0.3em;
  margin-top: 0.2em;
}

.saved-deck-item {
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  gap: 0.5em;
  border: 1px solid #ccc;
  padding: 0.5em;
  background-color: #fff;
}

.saved-deck-item img {
  width: 60px;
  height: auto;
  object-fit: cover;
}

.saved-deck-info {
  flex: 1 1 200px;
  display: flex;
  flex-direction: column;
  gap: 0.25em;
  min-width: 150px;
}

.saved-deck-info .row {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5em;
}
.saved-deck-info .row small {
  font-size: 0.75em;
  color: #555;
}
.saved-deck-buttons {
  display: flex;
  flex-direction: column;
  gap: 0.5em;
  min-width: 80px;
}
#toast-warning{
  font-size: 0.65rem;
  display: none;
  position: fixed;
  top: 30px;
  left: 50%;
  transform: translateX(-50%);
  background-color: rgba(220, 53, 69, 0.95); /* Bootstrap系red */
  color: white;
  padding: 12px 20px;
  border-radius: 8px;
  font-weight: bold;
  z-index: 9999;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2);
}
#deck-stats {
  margin-bottom: 1.5em; /* ボタンとの重なりを防ぐ */
}

#deck-stats .accident-rate {
  display: block;
  margin-top: 0.2em;
  font-size: 0.9em;
  color: #444;
}

footer {
  text-align: center;
  font-size: clamp(0.5rem, 1vw, 1rem);
  color: #666;
  padding: 1rem 0;
  background-color: #f9f9f9;
  line-height: 1.6;
}

footer a {
  color: #3366cc;
  text-decoration: none;
}

footer a:hover {
  text-decoration: underline;
}

@media (max-width: 1024px) {
      .card { width: calc(100% / 5 - 4px);}
    }
    @media (min-width: 700px) {
  #deck-layout {
    flex-direction: row;
    height: 100%;
    max-height: 25rem;
  }
  #deck-info {
  flex: 1;
  max-width: 50%; /* ← 適宜調整可能 */
  min-height: 5rem;
}
#deck-card-list {
  flex: 1;
  min-width: 0;
}
}
@media (max-width: 768px) {
  .header-nav a {
  font-size: 0.75em;
}
    .card-list {
      grid-template-columns: repeat(2, 1fr); /* 2列表示に */
      gap: 8px;
    }

    .card {
      width: calc(100% / 4 - 4px);
      font-size: 12px;
      padding: 0px;
    }
    .deck-card {
    width: 70px;   /* スマホではこのサイズに */
    height: auto;  /* 縦幅は画像サイズに任せる or 調整 */
  }
  .deck-bar-wrapper {
    position: relative;
  }
  .deck-summary {
    position: absolute;
    right: 20px;
    top: 0;
    width: 110px;               /* ← 統合：狭めサイズ */
    height: 100%;
    background: #fff;
    border-left: 1px solid #ccc;
    font-size: 10px;            /* ← 統合：文字サイズ調整 */
    line-height: 1.3;
    transform: translateX(120%);
    transition: transform 0.3s ease;
  }
  .deck-summary.open {
    transform: translateX(0%);
  }

  .deck-summary-toggle {
    display: inline-block;
    z-index: 11;
    background: #ccc;
    border: 1px solid #999;
    border-radius: 4px 0 0 4px;
    font-size: 0.3rem;
  }
  .analyze-button {
  font-size: 0.4rem;
}
    .filter-section,
    .sort-section {
      flex-direction: column;
      gap: 6px;
    }

    .card img {
      width: 100%;
      height: auto;
    }

    .card-detail {
      font-size: 13px;
    }
    .search-bar {
    display: flex;
    gap: 3px;
    align-items: center;
    width: 100%;
    box-sizing: border-box;
    padding: 0 0rem;
  }


  .search-bar input,
  .search-bar select,
  .search-bar button {
    min-width: 0;
    box-sizing: border-box;
    padding: 0.3rem 0.5rem;
    height: 1.8rem; /* 👈 ここで高さを統一 */
    line-height: 1.2rem;
  }

  .search-bar input {
    flex: 2;
    font-size: clamp(5px, 3vw, 18px);
    padding: 5px;
  }

  .search-bar select {
    flex: 1;
    font-size: 0.55rem;
    padding: 0.2rem;
  }

  .search-bar button {
    flex: 0 0 auto;
    font-size: clamp(5px, 2vw, 18px);
    padding: 1vw 5px;
    white-space: nowrap;
  }
  #deck-info div {
  font-size: 0.75rem;
}

  footer {
    font-size: 0.5rem; /* ← モバイルではさらに小さく */
    padding: 0.5rem 0;
  }
  }
  @media (max-width: 680px){
  .header-nav a {
  font-size: 0.65em;
}
}
@media (max-width: 630px){
  .header-nav a {
  font-size: 0.6em;
}
}
@media (max-width: 560px){
  .header-nav a {
    margin-left: 0.1em;
  font-size: 0.45em;
}
}
@media (max-width: 410px){
  .deck-card {
    height: auto;  /* 縦幅は画像サイズに任せる or 調整 */
  }
  .header-nav a {
  font-size: 0.23em;
}
.deck-summary {
  width: 95px;
  font-size: 8.5px;
}
.analyze-button {
  margin-top: 0rem;
  font-size: 0.25rem;
}
}
</style>
</head>
<body>
<!-- ヘッダー -->
<header class="main-header">
  <div class="header-logo">
    <img src="img/tatudosi.webp" alt="神託のメソロギア ロゴ" />
  </div>
  <nav class="header-nav">
    <a href="index.html">📖 一覧</a>
    <a href="deckmaker.html">🃏 デッキメーカー</a>
    <a href="cardcheker.html">📊 所持率チェッカー</a>
    <a href="#" style="text-decoration: line-through; pointer-events: none; color: #aaa;">📤 デッキ投稿</a>
  </nav>
</header>

<!--タブ切り替え-->
  <div class="tab-bar">
    <div id="tab1" class="tab active" onclick="switchTab('build')">
      <span>🃏 デッキ構築</span>
    </div>
    <div id="tab2" class="tab" onclick="switchTab('edit')">
      <span>💾 デッキ分析</span>
    </div>
  </div>

<!--デッキ構築タブ-->
<div class="tab-content active" id="build">

<!--メニューバー＆デッキバー上部固定用-->
<div class="fixed-top-bar">
<!--メニューバー-->
<div class="search-bar">
<input id="keyword" oninput="applyFilters()" placeholder="カード検索" type="text">
<button id="toggleOwnedBtn" onclick="toggleOwned()">所持カード未反映</button>
<select id="sort-select">
<option value="default">通常順</option>
<option value="cost-asc">コスト昇順</option>
<option value="cost-desc">コスト降順</option>
<option value="power-asc">パワー昇順</option>
<option value="power-desc">パワー降順</option>
</select>
<button onclick="openFilterModal()">📊 フィルター</button>
</div>

<!--フィルターモーダル-->
<div class="modal" id="filterModal">
<div class="modal-content">
<div id="main-filters">

</div>
<div>
<button onclick="toggleDetailFilters()">詳細フィルター開閉</button>
<div id="detail-filters" style="display: none;">

</div>

</div>
<div style="margin-top: 1rem;">
<button id="applyFilterBtn">この条件で絞り込む</button>
<button onclick="resetFilters()">リセット</button>
</div>
</div>
</div>

<!--デッキバー-->
<!-- 🔽 デッキバー全体のラッパーを追加 -->
<div class="deck-bar-wrapper">
  <div class="deck-bar-scroll">
    <div class="deck-bar-content">
      <div class="deck-bar-top" id="deckBarTop">
        <div id="deck-empty-text">
          <div style="font-size: 0.7rem;">デッキバー操作</div>
          <div class="deck-help" id="deckHelp">
            <div>
              【PC】<br>
              ・左クリック：追加<br>
              ・右クリック：削除<br>
            </div>
            <div>
              【スマホ】<br>
              ・上フリック：追加<br>
              ・下フリック：削除
            </div>
          </div>
        </div>
        <!-- JSでカードが並ぶ -->
      </div>
    </div>
  </div>

  <div class="deck-summary" id="deck-summary">
    <div class="deck-info"></div>
    <div class="analyze-button-wrapper">
      <button class="analyze-button" onclick="goToAnalyzeTab()">💾コード生成</button>
    </div>
  </div>

  <button class="deck-summary-toggle" onclick="toggleDeckSummary()">◀</button>
</div>


<!--使用不可種族表示非表示ボタン-->
<div class="deck-filter-bar">
  <button id="toggle-invalid-race" class="filter-toggle-button">✅使用不可種族を表示(モノクロ)</button>
</div>
</div>

<button id="scrollTopFixed" onclick="scrollToTop()">▲</button>

<!--カード一覧-->
<div class="grid" id="grid">

<!--龍年ボタン-->

<button id="dragon-mode-btn" style="display: none;">🐉 龍年モード</button>


</div>



</div>


<!--デッキ編集タブ-->
<div class="tab-content" id="edit">
  <div id="deck-layout">
<!--デッキリストゾーン-->
      <div id="deck-card-list" class="deck-section">
        <div id="deckcard-empty-message">デッキがここに表示されます</div>
        <!-- カード一覧（5列グリッド） -->
      </div>

<!--デッキ情報ゾーン-->
      <div id="deck-info" class="deck-section">
        <h3 style="margin: 0px 0px 0.5em; font-size: 0.8em;">デッキ情報</h3>
        <!-- デッキ名入力欄 -->
        <div class="deck-name-row">
          <input type="text" id="deck-name" placeholder="デッキ名を入力" />
        </div>

        <!-- デッキ枚数 -->
        <div class="deck-count">
          デッキ枚数：<span id="deck-count">0</span> /30~40
        </div>

        <!-- 使用種族 -->
        <div class="deck-race">
          使用種族：<span id="deck-races">未選択</span>
        </div>

        <!-- 旧神状況 -->
        <div class="deck-eldergod">
          旧神：<span id="deck-eldergod">未採用</span>
        </div>
        <!-- 代表カード -->
        <div class="deck-representative">
          代表カード：<span id="deck-representative">未選択</span>
          <div style="font-size: 14px;">タップで変更可能</div>
        </div>
        <!-- 使用タイプ内訳 -->
        <div class="deck-type-breakdown">
          <span class="type-count">🔵 チャージャー：<span id="count-charger">0</span></span>
          <span class="type-count">🟣 アタッカー：<span id="count-attacker">0</span></span>
          <span class="type-count">⚪️️️️️ ブロッカー：<span id="count-blocker">0</span></span>
        </div>
        <!--交換ポイント-->
        <div class="exchange-summary" style="margin-top: 0.5rem; font-size: 0.85rem;">
          <button id="exchange-toggle-btn" onclick="toggleExchange()">🟢 ポイント</button>
          <div id="exchange-point">🟢 必要ポイント：<span id="point-cost">0</span></div>
          <div id="exchange-diamond" style="display:none;">💎 必要ダイヤ：<span id="diamond-cost">0</span></div>
          <div id="exchange-sand" style="display:none;">
            🪨 必要砂
            <ul style="margin: 0.2rem 0 0 0.5rem;">
              <li>レジェンドの砂：<span id="sand-leg">0</span>個</li>
              <li>ゴールドの砂：<span id="sand-gld">0</span>個</li>
            </ul>
          </div>
          <div style="font-size: 14px;">※採用中のゴールドとレジェンドを全部交換した場合（今後所持カードから反映予定）</div>
        </div>
<!-- 🔽 デッキ分析結果 -->
      <button id="toggle-analysis-btn" onclick="toggleAnalysis()">🔍 分析を表示</button>
      <div id="analysis-section" class="deck-analysis" style="margin-top: 0.5rem; font-size: 0.85rem;">
            <div>
              <strong>レアリティ内訳：</strong>
              <span id="rarity-legend">🌈0</span> /
              <span id="rarity-gold">🟡 0</span> /
              <span id="rarity-silver">⚪️ 0</span> /
              <span id="rarity-bronze">🟤 0</span>
            </div>
            <!--メイン種族リスト-->
            <div>
              <strong>メイン種族率：</strong>
              <span id="race-rate"> 0%</span>
            </div>
            <!--コスト、パワー分布グラフ-->
            <div style="max-width: 100%;">
              <strong>コスト分布：</strong>
              <canvas id="costChart" height="80em"></canvas>
            </div>
            <div style="max-width: 100%; margin-top: 20px;">
              <strong>パワー分布：</strong>
              <canvas id="powerChart" height="80em"></canvas>
            </div>
            <div>
            <!--総コスト、パワー-->
              <strong>総コスト：</strong><span id="total-cost">0</span>  <strong>総パワー：</strong><span id="total-power">🔵0 / 🟣0</span>
            </div>
            <!--マリガンボタン-->
            <div>
              <label for="mulligan-count">マリガン枚数：</label>
              <select id="mulligan-count">
                <option value="0">マリガンなし</option>
                <option value="1">1枚マリガン</option>
                <option value="2">2枚マリガン</option>
                <option value="3">3枚マリガン</option>
                <option value="4" selected>4枚マリガン</option>
              </select>
              <strong>初手事故率：</strong>
              <span id="bad-hand-rate">0.0%</span>
              <span id="bad-hand-frequency">（ほぼ事故なし）</span>
              <div style="font-size: 14px;">※初手に出せるカードがマリガンしても来ない確率</div>
          </div>
        </div>
    <!-- 🔽 コード出力・入力ボタン群 -->
    <div class="deck-code-controls">
      <button id="generate-code-btn">📤 コード生成</button>
      <div id="copy-message" style="font-size: 0.85rem; color: green; margin-top: 0.5rem; display: none;">
        コピーしました！ </div>
      <button id="load-code-btn">📥 コード読み込み</button>
      <button onclick="saveDeckToLocalStorage()">💾 一時保存</button>
      <button id="resetDeckButton">デッキをリセット</button>
    </div>
      </div>
  </div>

<!-- 保存デッキ一覧表示用 -->
<div id="savedDeckCount" style="margin-bottom: 0.3em; font-size: 20px; color: #333;"></div>
<p style="color: red; font-weight: bold;font-size: 15px; margin: 0px;">
  ⚠️ デッキはブラウザに保存されます。キャッシュを削除するとデータが消えるのでご注意ください。
</p>
<div id="savedDeckList"></div>

</div>


<footer>
  <div class="site-description">
    <p>
      <strong>モスロギア</strong> はアプリ『神託のメソロギア』の非公式ファンサイトです。<br>
      カード一覧検索やデッキメーカー、デッキ分析などを通じて、プレイヤー向けに便利なデータベース機能を提供しています。
    </p>
  </div>

  <p>
    🔗 公式サイトはこちら 👉
    <a href="https://mythologiatheoracle.com/" target="_blank" rel="noopener noreferrer">
      神託のメソロギア公式サイト
    </a>
  </p>

  © 2025 Mesorogia Cards. All rights reserved.<br />
  当サイトは「神託のメソロギア」の非公式ファンサイトです。画像・データ等の著作権は各権利者に帰属します。<br />
  一部画像素材は「ジュエルセイバーFREE」<br />
  （<a href="https://www.jewel-s.jp/" target="_blank" rel="noopener">https://www.jewel-s.jp/</a>）を使用しています。<br />
  💬 ご要望・不具合報告 👉
  <a href="https://x.com/192837465aruneo" target="_blank" rel="noopener noreferrer">
    @192837465aruneo
  </a>
</footer>



<div id="toast-warning" ></div>

<script>
  // ==========================
  // グローバル変数
  // ==========================
  const deck = {}; // 現在のデッキ状態を保持（カードcd → 枚数）
let cardMap = {}; // ← グローバルに定義
let representativeCd = null;  // 代表カードのcd（5桁）
Chart.register(ChartDataLabels);
let isOwnedReflected = false;

  // ✅ JSONを読み込んでカード一覧＋詳細を生成
  async function loadCards() {
    const res = await fetch('/mesorogia/public/cards_latest.json');
    const cards = await res.json();

    const grid = document.getElementById('grid');
    grid.innerHTML = ''; // 一旦クリア

    cards.forEach(card => {
      // --- 🟢 一覧カード ---
      const cardDiv = document.createElement('div');
      cardDiv.classList.add('card');
      cardDiv.setAttribute('data-cd', card.cd);
      cardDiv.setAttribute('data-race', card.race);
      cardDiv.setAttribute('data-category', card.category);
      cardDiv.setAttribute('data-rarity', card.rarity);
      cardDiv.setAttribute('data-type', card.type);
      cardDiv.setAttribute('data-cost', card.cost);
      cardDiv.setAttribute('data-power', card.power);
      cardDiv.setAttribute('data-pack_name', card.pack_name);
      cardDiv.setAttribute('data-effectname', [card.effect_name1, card.effect_name2].filter(Boolean).join(','));
      cardDiv.setAttribute('data-field', card.field);
      cardDiv.setAttribute('data-BP_flag', String(card.BP_flag));
      cardDiv.setAttribute('data-special_ability', card.special_ability);
      cardDiv.setAttribute('data-destroy_opponent', String(card.destroy_opponent));
      cardDiv.setAttribute('data-draw', card.draw);
      cardDiv.setAttribute('data-graveyard_recovery', card.graveyard_recovery);
      cardDiv.setAttribute('data-cardsearch', card.cardsearch);
      cardDiv.setAttribute('data-destroy_self', card.destroy_self);
      cardDiv.setAttribute('onclick', 'expandCard(this);');

      const zoomBtn = document.createElement('div');
      zoomBtn.classList.add('zoom-btn');
      zoomBtn.innerText = '🔎';
      zoomBtn.setAttribute('onclick', 'handleZoomClick(event, this)');
      cardDiv.appendChild(zoomBtn);

      const ownedMark = document.createElement('div');
      ownedMark.classList.add('owned-mark');
      cardDiv.appendChild(ownedMark);

      const img = document.createElement('img');
      img.alt = card.name;
      img.loading = 'lazy';
      img.onclick = (e) => { e.stopPropagation(); addCard(card.cd); };
      img.src = `img/${card.cd}.webp`;
      cardDiv.appendChild(img);

      grid.appendChild(cardDiv);

      // --- 🟣 展開詳細も #grid 内に追加 ---
      const typeClass = `type-${card.type}`;
      const raceClass = `race-${card.race}`;
      const detailId = `detail-${card.cd}`;
      const effectText = [card.effect_text1, card.effect_text2].filter(Boolean).join('<br/>');

      const detailHtml = `
<div class="card-detail ${typeClass} ${raceClass}" data-name="${card.name}" id="${detailId}">
  <div class="card-name">${card.name}</div>
  <div class="card-meta">
    <span class="card-race">${card.race}</span> /
    <span class="card-category">${card.category}</span>
  </div>
  <div class="card-effect">
    ${effectText}
  </div>
</div>
    `;
      grid.insertAdjacentHTML('beforeend', detailHtml);
    });
        sortCards();
  }

//json読み込みモーダル反映
  async function generateFilterModal() {
    const res = await fetch('/mesorogia/public/cards_latest.json');
    const cards = await res.json();

    const mainFilters = document.getElementById('main-filters');
    const detailFilters = document.getElementById('detail-filters');

    mainFilters.innerHTML = '';
    detailFilters.innerHTML = '';

    // ✅ 並び順固定＋存在値補完
    const raceSet = new Set(cards.map(c => c.race));
    const races = ["ドラゴン", "アンドロイド", "エレメンタル", "ルミナス", "シェイド", "イノセント", "旧神"];
    raceSet.forEach(r => { if (!races.includes(r)) races.push(r); });

    const categorySet = new Set(cards.map(c => c.category));
    const categories = [
      "聖焔龍（フォルティア）", "ドラゴライダー", "メイドロボ", "アドミラルシップ",
      "ナチュリア", "鬼刹（きせつ）", "風花森", "ロスリス",
      "白騎士", "愚者愚者", "昏き霊園", "マディスキア", "ノーカテゴリ"
    ];
    categorySet.forEach(c => { if (!categories.includes(c)) categories.push(c); });

    const types = ["チャージャー", "アタッカー", "ブロッカー"];
    const rarities = ["レジェンド", "ゴールド", "シルバー", "ブロンズ"];

    const mainData = {
      "種族": races,
      "カテゴリ": categories,
      "タイプ": types,
      "レアリティ": rarities
    };

    Object.entries(mainData).forEach(([key, values]) => {
      const section = document.createElement('div');
      section.innerHTML = `
      <strong>${key}</strong>
      <div class="filter-group" data-key="${key}">
        ${values.map(val => `<button class="filter-btn" data-value="${val}">${val}</button>`).join('')}
      </div>
    `;
      mainFilters.appendChild(section);
    });

    // ✅ コスト・パワー
    const costs = [...new Set(cards.map(c => c.cost))].sort((a, b) => a - b);
    const powers = [...new Set(cards.map(c => c.power))].sort((a, b) => a - b);

    const costOptions = costs.map(v => `<option value="${v}">${v}</option>`).join('');
    const powerOptions = powers.map(v => `<option value="${v}">${v}</option>`).join('');

    mainFilters.insertAdjacentHTML('beforeend', `
    <br/><strong>コスト：</strong>
    <select id="cost-min">
      <option value="">下限なし</option>
      ${costOptions}
    </select>
    <select id="cost-max">
      <option value="">上限なし</option>
      ${costOptions}
    </select>

    <br/><strong>パワー：</strong>
    <select id="power-min">
      <option value="">下限なし</option>
      ${powerOptions}
    </select>
    <select id="power-max">
      <option value="">上限なし</option>
      ${powerOptions}
    </select>
  `);

    // ✅ 詳細フィルター
    const packs = [...new Set(cards.map(c => c.pack_name))];
    const effects = [...new Set(
      cards.flatMap(c => [c.effect_name1, c.effect_name2]).filter(Boolean)
    )];
    const fields = [...new Set(cards.map(c => c.field))];
    const skills = [...new Set(cards.map(c => c.special_ability))];

    const detailData = {
      "パック名": packs,
      "効果名": effects,
      "BP要素": ["true", "false"],
      "フィールド": fields,
      "特殊効果": skills
    };

    Object.entries(detailData).forEach(([key, values]) => {
      const group = document.createElement('div');
      group.classList.add('filter-group');
      group.dataset.key = key;

      const label = `<div class="filter-label">${key}</div>`;
      const buttons = values.map(val => {
        // ✅ BP要素の表示だけ置き換え
        if (key === "BP要素") {
          return `<button class="filter-btn" data-value="${val}">${val === "true" ? "あり" : "なし"}</button>`;
        }
        return `<button class="filter-btn" data-value="${val}">${val}</button>`;
      }).join('');

      group.innerHTML = label + buttons;
      detailFilters.appendChild(group);
    });

    // ✅ その他条件を detail-filters 内に生成
    const extraFlags = [
      { key: "draw", label: "ドロー効果" },
      { key: "graveyard_recovery", label: "墓地回収" },
      { key: "cardsearch", label: "カードサーチ" },
      { key: "destroy_opponent", label: "相手破壊" },
      { key: "destroy_self", label: "自分破壊" }
    ];

    const extraConditions = document.createElement('div');
    extraConditions.id = 'extra-conditions';
    extraConditions.classList.add('filter-group-group');
    extraConditions.innerHTML = `<div class="filter-section-title">その他条件</div>`;

    extraFlags.forEach(flag => {
      const group = document.createElement('div');
      group.classList.add('filter-group');
      group.dataset.key = flag;
      group.innerHTML = `<button class="filter-btn" data-value="true">${flag.label}</button>`;
      extraConditions.appendChild(group);
    });

    detailFilters.appendChild(extraConditions);
  }

    loadCards();
    generateFilterModal();





// カード情報を集約するマップを作る（type, race, name）
function rebuildCardMap() {
  cardMap = {}; // まず空のマップに初期化（再構築）

  // 現在表示されている .card 要素をすべて走査
  document.querySelectorAll('.card').forEach(card => {
    const cd = card.dataset.cd; // カード識別ID（8桁）
    if (!cd) return; // cdがない要素は無視

        // allCardMap からコピーする
    if (allCardMap[cd]) {
      cardMap[cd] = { ...allCardMap[cd] };
    } else {
      // なければ直接構築（念のためフォールバック）
    cardMap[cd] = {
      type: card.dataset.type || "",   // タイプ（チャージャー等）
      race: card.dataset.race || "",   // 種族（ドラゴン等）
      name: card.querySelector("img")?.alt || "", // カード名（画像のalt属性）

      cost: parseInt(card.dataset.cost) || 0,  // 🔹 コスト（整数変換・なければ0）
      power: parseInt(card.dataset.power) || 0, // 🔹 パワー（整数変換・なければ0）
      rarity: card.dataset.rarity || ""
    };
  }
  });
}

  let allCardMap = {};

    function initializeAllCardMap() {
      document.querySelectorAll('.card').forEach(card => {
        const cd = card.dataset.cd;
        if (!cd) return;

        allCardMap[cd] = {
          type: card.dataset.type || "",
          race: card.dataset.race || "",
          name: card.querySelector("img")?.alt || "",
          cost: parseInt(card.dataset.cost) || 0,
          power: parseInt(card.dataset.power) || 0,
          rarity: card.dataset.rarity || ""
        };
      });

      // 🔽 これを追加
      cards = Object.entries(allCardMap).map(([cd, data]) => ({
        cd,
        ...data
      }));
    }






  // ==========================
  // DOM読み込み後の初期化処理
  // ==========================
  document.addEventListener("DOMContentLoaded", function () {
    initializeAllCardMap();
    rebuildCardMap();
    updateSavedDeckList();



    // デッキバー初期化
    const deckBarTop = document.getElementById("deckBarTop");
    // デッキバー内のカードに右クリック防止処理を追加
    document.addEventListener("contextmenu", e => {
      const deckBarTop = document.getElementById("deckBarTop");
      if (deckBarTop && deckBarTop.contains(e.target)) {
        e.preventDefault(); // 🔴 deckBarTop内であれば常に抑制
      }
    });



    // --------------------------
    // フィルター関連イベント登録
    // --------------------------

    const keywordInput = document.getElementById("keyword");
    if (keywordInput) {
      keywordInput.addEventListener("input", applyFilters);
    }

    document.getElementById('main-filters').addEventListener("click", e => {
      if (e.target.matches('.filter-btn')) {
        e.target.classList.toggle("selected");
        applyFilters();
      }
    });


    // コスト・パワー範囲
    document.querySelectorAll("select").forEach(select => {
      select.addEventListener("change", applyFilters);
    });

    const applyBtn = document.getElementById("applyFilterBtn");
    if (applyBtn) applyBtn.addEventListener("click", () => {
      applyFilters();
      closeFilterModal();
    });

    const resetBtn = document.getElementById("resetFilterBtn");
    if (resetBtn) resetBtn.addEventListener("click", resetFilters);

    const sortSelect = document.getElementById("sort-select");
    if (sortSelect) sortSelect.addEventListener("change", () => {
      sortCards();
      applyFilters();
    });



    // カード追加関数（画像クリックで使う）
    window.addCard = function (cd) {
      // 該当カードの種族情報を取得
      const card = document.querySelector(`.card[data-cd="${cd}"]`);
      const race = card?.dataset.race || "";
      const raceType = getRaceType(race); // 🔑 ここ追加

      // すでに旧神が入っていて、違うカードを追加しようとしている
      const hasKyuushin = Object.keys(deck).some(id => {
        const r = document.querySelector(`.card[data-cd="${id}"]`)?.dataset.race;
        return r === "旧神";
      });

      const isKyuushin = race === "旧神";

      if (isKyuushin && hasKyuushin && !(cd in deck)) return; // 他の旧神がいたら追加不可
      if ((deck[cd] || 0) >= 3) return; // 3枚制限
      if (isKyuushin && (deck[cd] || 0) >= 1) return; // 旧神は1枚まで

      // ✅ メイン種族制限（最大1種まで）
      if (raceType === "main") {
        const mainRacesInDeck = Object.keys(deck)
          .map(id => {
            const r = (document.querySelector(`.card[data-cd="${id}"]`) || document.querySelector(`.deck-card[data-cd="${id}"]`))?.dataset.race;
            return getRaceType(r) === "main" ? r : null;
          })
          .filter(Boolean);

        const combined = [...mainRacesInDeck, race];
        const unique = [...new Set(combined)];

        if (unique.length > 1) return;
      }

      deck[cd] = (deck[cd] || 0) + 1;
      updateDeck();
      updateCardDisabling(); // ✅ これがなければ一覧の更新がされない
      applyGrayscaleFilter();
      applyFilters();
      checkDeckEmpty();
    }


    // カードクリック操作（左クリック追加、右クリック削除）
    document.querySelectorAll('.card').forEach(card => {
      const cd = card.dataset.cd;

      card.addEventListener('mousedown', e => {
        // IMG または 🔎（zoom-btn）を押した場合はカード追加しない
        if (e.target.tagName === 'IMG' || e.target.classList.contains('zoom-btn')) return;
        handleClick(e, cd);
      });
      card.addEventListener('contextmenu', e => e.preventDefault());
    });

    sortCards();
  });


  // ==========================
  // フィルター処理
  // ==========================
    // フィルターモーダルを開く
      function openFilterModal() {
        document.getElementById("filterModal").style.display = "flex";
        const detail = document.getElementById("detail-filters");
        if (detail) detail.style.display = "none"; // 詳細フィルターは初期状態で閉じる

      }

      // フィルターモーダルを閉じる
      function closeFilterModal() {
        document.getElementById("filterModal").style.display = "none";
      }

      // 詳細フィルターをトグル
      function toggleDetailFilters() {
        const detail = document.getElementById("detail-filters");
        detail.style.display = (detail.style.display === "none") ? "block" : "none";
      }

  function applyFilters() {
    const filters = {};
    const keyword = document.getElementById("keyword").value.trim().toLowerCase();

    // ✅ JSON/data属性に合わせたマップ
    const attrMap = {
      "タイプ": "type",
      "種族": "race",
      "カテゴリ": "category",
      "レアリティ": "rarity",
      "パック名": "pack_name",       // pack → pack_name に合わせる
      "効果名": "effectname",
      "特殊効果": "special_ability", // skill → special_ability に合わせる
      "BP要素": "BP_flag",           // bp → BP_flag に合わせる
      "フィールド": "field",
      "破壊": "destroy_opponent"     // destroy → destroy_opponent に合わせる
    };

    // ✅ ボタン選択値の収集
    document.querySelectorAll(".filter-group").forEach(group => {
      const key = group.getAttribute("data-key");
      const selected = Array.from(group.querySelectorAll(".filter-btn.selected"))
        .map(btn => btn.getAttribute("data-value"));
      if (selected.length > 0) filters[key] = selected;
    });

    // ✅ 数値範囲
    const costMin = parseIntOrNull("cost-min");
    const costMax = parseIntOrNull("cost-max");
    const powerMin = parseIntOrNull("power-min");
    const powerMax = parseIntOrNull("power-max");
    if (costMin !== null || costMax !== null) filters["コスト"] = [costMin, costMax];
    if (powerMin !== null || powerMax !== null) filters["パワー"] = [powerMin, powerMax];

    // ✅ 各カードに適用
    document.querySelectorAll(".card").forEach(card => {
      const cd = card.getAttribute("data-cd");
      const detail = document.getElementById("detail-" + cd);
      const text = (
        card.innerText + " " +
        (detail ? detail.innerText : "") + " " +
        (card.dataset.race || "") + " " +
        (card.dataset.category || "")
      ).toLowerCase();

      let visible = true;

      for (let key in filters) {
        if (key === "コスト" || key === "パワー") {
          const val = parseInt(card.dataset[key === "コスト" ? "cost" : "power"]);
          const [min, max] = filters[key];
          if ((min !== null && val < min) || (max !== null && val > max)) {
            visible = false;
            break;
          }
          continue;
        }

        const attr = attrMap[key];
        const cardVal = card.dataset[attr] || "";

        // true/false系の単一値は文字列比較する
        if (["BP要素", "破壊", "フィールド"].includes(key)) {
          if (!filters[key].includes(cardVal)) {
            visible = false;
            break;
          }
          continue;
        }

        // カンマ区切りなら複数比較
        const values = cardVal.split(",");
        const match = values.some(val => filters[key].includes(val));
        if (!match) {
          visible = false;
          break;
        }
      }

      if (keyword && !text.includes(keyword)) visible = false;

      card.style.display = visible ? "" : "none";
    });

    // 展開中の詳細を閉じる
    const active = document.querySelector(".card-detail.active");
    if (active) active.remove();

    sortCards();
    applyGrayscaleFilter();


  }



  function resetFilters() {
    document.querySelectorAll(".filter-btn.selected").forEach(btn => btn.classList.remove("selected"));
    document.querySelectorAll(".card").forEach(card => card.style.display = "");
    document.querySelectorAll("select").forEach(sel => sel.value = "");
    document.getElementById("keyword").value = "";
    document.getElementById("sort-select").value = "default";
    const active = document.querySelector(".card-detail.active");
    if (active) active.remove();
    sortCards();
  }

  function parseIntOrNull(id) {
    const el = document.getElementById(id);
    return (!el || el.value === "") ? null : parseInt(el.value);
  }

  // ==========================
  // ソート処理
  // ==========================
  function sortCards() {
    const sortValue = document.getElementById("sort-select").value;
    const grid = document.getElementById("grid");
    const cards = Array.from(grid.children).filter(card => card.classList.contains("card"));

    const getTypeOrder = (type) => {
      if (type === "チャージャー") return 0;
      if (type === "アタッカー") return 1;
      if (type === "ブロッカー") return 2;
      return 3;
    };

    cards.sort((a, b) => {
      const typeA = getTypeOrder(a.dataset.type);
      const typeB = getTypeOrder(b.dataset.type);
      const costA = parseInt(a.dataset.cost);
      const costB = parseInt(b.dataset.cost);
      const powerA = parseInt(a.dataset.power);
      const powerB = parseInt(b.dataset.power);
      const cdA = parseInt(a.dataset.cd);
      const cdB = parseInt(b.dataset.cd);

      switch (sortValue) {
        case "cost-asc": return costA - costB || typeA - typeB || powerA - powerB || cdA - cdB;
        case "cost-desc": return costB - costA || typeA - typeB || powerA - powerB || cdA - cdB;
        case "power-asc": return powerA - powerB || typeA - typeB || costA - costB || cdA - cdB;
        case "power-desc": return powerB - powerA || typeA - typeB || costA - costB || cdA - cdB;
        default: return typeA - typeB || costA - costB || powerA - powerB || cdA - cdB;
      }
    });

    cards.forEach(card => grid.appendChild(card));
  }

  // ==========================
  // カード詳細展開
  // ==========================
  function expandCard(clickedCard) {
    const cd = clickedCard.getAttribute('data-cd');
    const grid = document.getElementById('grid');
    const existing = document.querySelector('.card-detail.active');

    if (existing && existing.getAttribute('data-cd') === cd) {
      existing.remove();
      return;
    }

    if (existing) existing.remove();

    const detail = document.getElementById('detail-' + cd);
    if (!detail) return;

    const cloned = detail.cloneNode(true);
    cloned.style.display = 'block';
    cloned.classList.add('active');
    cloned.setAttribute('data-cd', cd);

    const cards = Array.from(grid.children).filter(
      c => c.classList.contains("card") && c.style.display !== "none"
    );
    const clickedIndex = cards.indexOf(clickedCard);

    let columns = 7;
    if (grid.clientWidth < 768) columns = 4;
    else if (grid.clientWidth < 1024) columns = 5;

    const rowStart = Math.floor(clickedIndex / columns) * columns;
    const rowEnd = Math.min(rowStart + columns - 1, cards.length - 1);
    const insertAfter = cards[rowEnd];
    insertAfter.insertAdjacentElement('afterend', cloned);
  }


  // ==========================
  // 指定されたカードcdが旧神かどうかを判定する関数
  // ==========================
  function isKyuushinCard(cd) {
    const cardEl =
      document.querySelector(`.card[data-cd="${cd}"]`) ||
      document.querySelector(`.deck-card[data-cd="${cd}"]`);
    const race = cardEl?.dataset.race || "";
    return race === "旧神";
  }


function getRaceType(race) {
  if (race === "旧神") return "kyuushin";
  if (race === "イノセント") return "innocent";
  if (["ドラゴン", "アンドロイド", "エレメンタル", "ルミナス", "シェイド"].includes(race)) return "main";
  return "other";
}

  // ==========================
  // デッキ追加・削除（PC用クリック）
  // ==========================
  function handleClick(e, cd) {
    e.preventDefault(); // 右クリックメニュー防止

    const cardEl = document.querySelector(`.card[data-cd="${cd}"]`) || document.querySelector(`.deck-card[data-cd="${cd}"]`);
    const race = cardEl?.dataset.race || "";
    const raceType = getRaceType(race);
    const isKyuushin = race === "旧神";

    if (e.button === 2) {
      // 右クリック → 減らす or 削除
      if (deck[cd] > 1) {
        deck[cd]--;
      } else {
        delete deck[cd];
      }

    } else {
      // 左クリック → 追加（制限あり）
      // 同名カードは3枚まで
      if ((deck[cd] || 0) >= 3) return;

      // 旧神は1種類1枚まで
      if (isKyuushin) {
        if ((deck[cd] || 0) >= 1) return;
        const hasOtherKyuushin = Object.keys(deck).some(id =>
          isKyuushinCard(id) && id !== cd
        );
        if (hasOtherKyuushin) return;
      }

      // メイン種族制限（最大1種）
      if (raceType === "main") {
        const mainRacesInDeck = Object.keys(deck)
          .map(id => {
            const el = document.querySelector(`.card[data-cd="${id}"]`) || document.querySelector(`.deck-card[data-cd="${id}"]`);
            const r = el?.dataset.race || "";
            return getRaceType(r) === "main" ? r : null;
          })
          .filter(Boolean);

        const combined = [...mainRacesInDeck, race];
        const unique = [...new Set(combined)];

        if (unique.length > 1) return;
      }

      // 制限クリアしたら追加
      deck[cd] = (deck[cd] || 0) + 1;
    }

    // 表示更新
    updateDeck();
    updateCardDisabling();
    applyGrayscaleFilter();
    checkDeckEmpty();
  }


  // デッキバー更新

function isMobile() {
  return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
}


function updateDeck() {
  const deckBarTop = document.getElementById("deckBarTop");
  deckBarTop.innerHTML = '';

  //デッキヘルプ表示
    // 空テキスト要素を必ず最初に作る
  const emptyText = document.createElement('div');
  emptyText.id = 'deck-empty-text';
  emptyText.innerHTML = `
      <div id="deck-empty-text">
        <div style="font-size: 0.7rem;">デッキバー操作</div>
          <div class="deck-help" id="deckHelp">
            <div>
            【PC】<br>
            ・左クリック：追加<br>
            ・右クリック：削除<br>
            </div>
            <div>
            【スマホ】<br>
            ・上フリック：追加<br>
            ・下フリック：削除
            </div>
          </div>
      </div>
  `;

  deckBarTop.appendChild(emptyText);
  // 🔽 ソート対象のdeckを配列に変換
  const entries = Object.entries(deck);

  // 🔽 タイプ順に並べるための優先度設定
  const typeOrder = { "チャージャー": 0, "アタッカー": 1, "ブロッカー": 2 };

  // 🔽 カードを通常順（タイプ→コスト→パワー→cd）に並べ替え
  entries.sort((a, b) => {
    const [cdA] = a;
    const [cdB] = b;
    const cardA = cardMap[cdA];
    const cardB = cardMap[cdB];

    if (!cardA || !cardB) return 0; // 情報不足なら順序維持

    const typeA = typeOrder[cardA.type] ?? 99;
    const typeB = typeOrder[cardB.type] ?? 99;
    if (typeA !== typeB) return typeA - typeB;

    const costA = parseInt(cardA.cost) || 0;
    const costB = parseInt(cardB.cost) || 0;
    if (costA !== costB) return costA - costB;

    const powerA = parseInt(cardA.power) || 0;
    const powerB = parseInt(cardB.power) || 0;
    if (powerA !== powerB) return powerA - powerB;

    return cdA.localeCompare(cdB); // 最後にcdで並べる
  });

  // 🔽 ソートされた順でデッキバーにカードを表示
  for (const [cd, count] of entries) {
    const cardEl = document.createElement('div');
    cardEl.className = 'deck-card';
    cardEl.dataset.cd = cd;

    const race = cardMap[cd]?.race || "";
    cardEl.dataset.race = race;

    const img = document.createElement('img');
    img.src = `img/${cd.slice(0, 5)}.webp`;
    img.alt = cd;

    if (!isCardAllowed(cd)) cardEl.classList.add('grayscale');
    cardEl.appendChild(img);

    const badge = document.createElement('div');
    badge.className = 'count-badge';
    badge.textContent = count;
    cardEl.appendChild(badge);

    // スマホ、PCでの追加削除処理
    if (isMobile()) {
      let touchStartX = 0;
      let touchStartY = 0;
      let dummy = null;

      cardEl.addEventListener('touchstart', e => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;

        cardEl.style.transition = '';
        cardEl.style.zIndex = '2000';
      });

      cardEl.addEventListener('touchmove', e => {
        const currentX = e.touches[0].clientX;
        const currentY = e.touches[0].clientY;

        const diffX = currentX - touchStartX;
        const diffY = currentY - touchStartY;

        if (Math.abs(diffX) > Math.abs(diffY)) return;

        let limitedDiffY = diffY;
        if (limitedDiffY > 40) limitedDiffY = 40;
        if (limitedDiffY < -40) limitedDiffY = -40;

        cardEl.style.transform = `translateY(${limitedDiffY}px)`;
      });


      cardEl.addEventListener('touchend', e => {
        const touchEndY = e.changedTouches[0].clientY;
        const diffY = touchStartY - touchEndY;
        const threshold = 20;

        cardEl.style.transition = 'transform 0.2s ease';

        const cleanUp = () => {
          cardEl.style.transform = 'translateY(0)';
          cardEl.style.zIndex = ''; // ← 忘れず戻す
        };

        if (Math.abs(diffY) > threshold) {

          if (diffY > 0) {
            // === 上フリック → 追加 ===

            if (deck[cd] >= 3) {
              cleanUp();
              return;
            }

            const isOldGod = cardMap[cd]?.race === "旧神";
            if (isOldGod) {
              const otherOldGodExists = Object.keys(deck).some(cdKey =>
                cardMap[cdKey]?.race === "旧神" && cdKey !== cd
              );
              if (otherOldGodExists || deck[cd] >= 1) {
                cleanUp();
                return;
              }
            }

            cardEl.style.transform = 'translateY(-40px)';
            setTimeout(() => {
              cardEl.style.transition = '';
              cleanUp();

              deck[cd] = (deck[cd] || 0) + 1;
              updateDeck();
              updateCardDisabling();
              applyGrayscaleFilter();
              checkDeckEmpty();
            }, 200);

          } else {
            // === 下フリック → 削除 ===
            cardEl.style.transform = 'translateY(40px)';
            setTimeout(() => {
              cardEl.style.transition = '';
              cleanUp();

              if (deck[cd] > 1) deck[cd]--;
              else delete deck[cd];
              updateDeck();
              updateCardDisabling();
              applyGrayscaleFilter();
              checkDeckEmpty();
            }, 200);
          }

        } else {
          // === 距離未満 → 元に戻すだけ ===
          setTimeout(() => {
            cardEl.style.transition = '';
            cleanUp();
            checkDeckEmpty()
          }, 200);
        }
      });

    } else {
      // PC：右クリックで削除
      cardEl.addEventListener('mousedown', e => handleClick(e, cd));
      cardEl.addEventListener('contextmenu', e => e.preventDefault());
      checkDeckEmpty()
    }

    deckBarTop.appendChild(cardEl);

  }

  // 🔽 サマリー表示
  const summary = document.getElementById("deck-summary");

  // 🔽 一度中身を全部消すのではなく、必要な部分だけ消す
  // 情報部分を入れる専用ラッパーを探すか、なければ作る
  let info = summary.querySelector(".deck-info");
  if (!info) {
    info = document.createElement("div");
    info.className = "deck-info";
    summary.insertBefore(info, summary.firstChild); // ボタンの前に配置
  }

  let total = 0;
  const typeCount = { "チャージャー": 0, "アタッカー": 0, "ブロッカー": 0 };
  const races = new Set();
  let hasOldGod = false;

  for (const [cd, count] of Object.entries(deck)) {
    const card = cardMap[cd];
    if (!card) continue;
    total += count;
    typeCount[card.type] += count;
      // 使用種族としてカウント（イノセント・旧神は除く）
    if (card.race !== "イノセント" && card.race !== "旧神") races.add(card.race);
    if (card.race === "旧神") hasOldGod = true;
  }

  const raceLine = "使用種族：" + (races.size > 0 ? Array.from(races).join("/") : "なし");
  const oldGodLine = `旧神：${hasOldGod ? "採用中" : "未採用"}`;
  const typeLine = `🔵 ${typeCount["チャージャー"]} 🟣 ${typeCount["アタッカー"]} ⚪️ ${typeCount["ブロッカー"]}`;

  // 改行で分けて表示
  info.innerHTML = `
  デッキ枚数：${total} /30~40<br>
  ${raceLine}<br>
  ${oldGodLine}<br>
  ${typeLine}
`;

  updateGrayscaleState();
  updateCardDisabling();
  // 🔽 デッキ情報（種族・タイプなど）表示を更新
  const deckCards = Object.entries(deck).flatMap(([cd, count]) => {
    const card = cardMap[cd];
    if (!card) return [];
    return Array(count).fill({
      種族: card.race,
      タイプ: card.type
    });
  });
  updateDeckSummary(deckCards);
  // 🔽 デッキ配列をカード詳細付きで展開して分析
  const expandedDeck = Object.entries(deck).flatMap(([cd, count]) => {
    const card = cardMap[cd];
    if (!card) return [];
    return Array(count).fill({ ...card });
  });

  document.querySelectorAll('.deck-card').forEach(card => {
    card.addEventListener('contextmenu', e => {
      e.preventDefault(); // 🔴 右クリックメニュー抑制
    });
  });
  currentDeck = expandedDeck; // グローバルに設定（分析関数用）
  rebuildCardMap();
  updateDeckAnalysis(); // 分析実行
  applyFilters();
  checkDeckEmpty()
}

    //デッキバー説明表示
    function checkDeckEmpty() {
      const deckCards = document.querySelectorAll('.deck-card'); // デッキ欄のカードを数える
      const emptyText = document.getElementById('deck-empty-text');

      if (deckCards.length === 0) {
        emptyText.style.display = 'block';  // 1枚もなければ表示
      } else {
        emptyText.style.display = 'none';   // 1枚以上あれば非表示
      }
    }


//分析表示/非表示ボタン
  function toggleAnalysis() {
    const section = document.getElementById("analysis-section");
    const btn = document.getElementById("toggle-analysis-btn");
    const isOpen = section.classList.toggle("open");
    btn.textContent = isOpen ? "⬆ 分析を隠す" : "🔍 分析を表示";
  }


//カード分析
  function updateDeckAnalysis() {
    const deck = currentDeck; // デッキデータ

    // 初期化
    let totalCost = 0;
    let costCount = 0; // 1以上のコストを持つカード数

    let totalChargerPower = 0;
    let chargerCount = 0;

    let totalAttackerPower = 0;
    let attackerCount = 0;
    let rarityCounts = { LEG: 0, GLD: 0, SIL: 0, BRZ: 0 };
    let raceCounts = {};

    // カウント処理
    deck.forEach(card => {
      const cost = Number(card.cost) || 0;
      const power = Number(card.power) || 0;
      const rarity = card.rarity || "";
      const race = card.race || "";
      const type = card.type || "";

      if (cost >= 1) {
        totalCost += cost;
        costCount++;
      }

      if (type === "チャージャー") {
        totalChargerPower += power;
        chargerCount++;
      } else if (type === "アタッカー") {
        totalAttackerPower += power;
        attackerCount++;
      }

      // レアリティ
      if (rarity.includes("レジェンド")) rarityCounts.LEG++;
      else if (rarity.includes("ゴールド")) rarityCounts.GLD++;
      else if (rarity.includes("シルバー")) rarityCounts.SIL++;
      else if (rarity.includes("ブロンズ")) rarityCounts.BRZ++;

      // 種族
      if (!raceCounts[race]) raceCounts[race] = 0;
      raceCounts[race]++;
    });
    updateDeckAnalysisCharts();

    // 上位3種族（メイン種族）
    const sortedRaces = Object.entries(raceCounts).sort((a, b) => b[1] - a[1]);
    const mainRace = sortedRaces[0] || [0];
    const mainRate = deck.length ? Math.round((mainRace[1] / deck.length) * 100) : 0;

    // 初手事故率（コスト5以上のカードが初手8枚に8枚とも含まれる確率）
    const mulliganCount = parseInt(document.getElementById("mulligan-count").value);
    const badRate = calcBadHandRate(deck, mulliganCount);



    // 表示更新
    document.getElementById("rarity-legend").textContent = `🌈 ${rarityCounts.LEG}`;
    document.getElementById("rarity-gold").textContent = `🟡 ${rarityCounts.GLD}`;
    document.getElementById("rarity-silver").textContent = `⚪️ ${rarityCounts.SIL}`;
    document.getElementById("rarity-bronze").textContent = `🟤 ${rarityCounts.BRZ}`;
    document.getElementById("race-rate").textContent = `${mainRace[0]}: ${mainRate}%`;
    document.getElementById("total-cost").textContent = totalCost;
    document.getElementById("total-power").textContent = `🔵${totalChargerPower}  🟣${totalAttackerPower}`;
    document.getElementById("bad-hand-rate").textContent = `${badRate.toFixed(1)}%`;

    // 🔽 未所持想定での交換コスト計算（レジェンド・ゴールドのみ）
    const legendCount = rarityCounts.LEG;
    const goldCount = rarityCounts.GLD;

    const pointCost = legendCount * 300 + goldCount * 150;
    const diamondCost = legendCount * 4000 + goldCount * 1000;
    const sandLeg = legendCount * 300;
    const sandGld = goldCount * 150;

    document.getElementById("point-cost").textContent = pointCost;
    document.getElementById("diamond-cost").textContent = diamondCost;
    document.getElementById("sand-leg").textContent = sandLeg;
    document.getElementById("sand-gld").textContent = sandGld;


  }

//コストパワー棒グラフ
  let costChartInstance = null;
  let powerChartInstance = null;

  function updateDeckAnalysisCharts() {
    const deck = currentDeck; // デッキのカード配列
    const costCount = {};
    const powerCount = {};

    const alwaysShowCosts = [2, 4, 6, 8, 10, 12];
    const alwaysShowPowers = [0, 4, 5, 6, 7, 8, 12, 16];

    deck.forEach(card => {
      const cost = parseInt(card.cost, 10);
      const power = parseInt(card.power, 10);
      if (!isNaN(cost)) costCount[cost] = (costCount[cost] || 0) + 1;
      if (!isNaN(power)) powerCount[power] = (powerCount[power] || 0) + 1;
    });

    const costLabels = [...new Set([...alwaysShowCosts, ...Object.keys(costCount).map(Number)])].sort((a, b) => a - b);
    const costData = costLabels.map(c => costCount[c] || 0);
    const powerLabels = [...new Set([...alwaysShowPowers, ...Object.keys(powerCount).map(Number)])].sort((a, b) => a - b);
    const powerData = powerLabels.map(p => powerCount[p] || 0);

    const costCtx = document.getElementById("costChart").getContext("2d");
    const powerCtx = document.getElementById("powerChart").getContext("2d");

    if (costChartInstance) costChartInstance.destroy();
    if (powerChartInstance) powerChartInstance.destroy();

    const typeList = ['チャージャー', 'アタッカー', 'ブロッカー'];
    const typeColors = {
      'チャージャー': 'rgba(119, 170, 212, 0.7)',
      'アタッカー': 'rgba(125, 91, 155, 0.7)',
      'ブロッカー': 'rgba(214, 212, 204, 0.7)'
    };

    const powerTypeCount = {};
    deck.forEach(card => {
      const power = parseInt(card.power, 10);
      const type = card.type;
      if (!isNaN(power) && typeList.includes(type)) {
        if (!powerTypeCount[power]) powerTypeCount[power] = {};
        powerTypeCount[power][type] = (powerTypeCount[power][type] || 0) + 1;
      }
    });

    const powerLabelsStacked = [...new Set([...alwaysShowPowers, ...Object.keys(powerTypeCount).map(Number)])].sort((a, b) => a - b);

    const powerDatasets = typeList.map(type => ({
      label: type,
      data: powerLabelsStacked.map(p => (powerTypeCount[p] && powerTypeCount[p][type]) ? powerTypeCount[p][type] : 0),
      backgroundColor: typeColors[type],
      stack: 'stack1',
      datalabels: {
        color: '#000',
        font: { size: 10 },
        anchor: 'center',
        align: 'center',
        formatter: value => value === 0 ? '' : value
      }
    }));
    const costTypeCount = {};

    deck.forEach(card => {
      const cost = parseInt(card.cost, 10);
      const type = card.type;
      if (!isNaN(cost) && typeList.includes(type)) {
        if (!costTypeCount[cost]) costTypeCount[cost] = {};
        costTypeCount[cost][type] = (costTypeCount[cost][type] || 0) + 1;
      }
    });

    const costLabelsStacked = [...new Set([...alwaysShowCosts, ...Object.keys(costTypeCount).map(Number)])].sort((a, b) => a - b);

    const costDatasets = typeList.map(type => ({
      label: type,
      data: costLabelsStacked.map(c => (costTypeCount[c] && costTypeCount[c][type]) ? costTypeCount[c][type] : 0),
      backgroundColor: typeColors[type],
      stack: 'stack1',
      datalabels: {
        color: '#000',
        font: { size: 10 },
        anchor: 'center',
        align: 'center',
        formatter: value => value === 0 ? '' : value
      }
    }));

    costChartInstance = new Chart(costCtx, {
      type: 'bar',
      data: {
        labels: costLabelsStacked,
        datasets: costDatasets
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          tooltip: { enabled: false },
          datalabels: {
            display: true
          }
        },
        scales: {
          x: {
            stacked: true,
            grid: { display: false },
            ticks: { color: '#333', font: { size: 11 } }
          },
          y: {
            stacked: true,
            display: false,
            beginAtZero: true,
            grid: { display: false }
          }
        }
      },
      plugins: [ChartDataLabels]
    });

    powerChartInstance = new Chart(powerCtx, {
      type: 'bar',
      data: {
        labels: powerLabelsStacked,
        datasets: powerDatasets
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          tooltip: { enabled: false },
          datalabels: {
            display: true
          }
        },
        scales: {
          x: {
            stacked: true,
            grid: { display: false },
            ticks: { color: '#333', font: { size: 11 } }
          },
          y: {
            stacked: true,
            display: false,
            beginAtZero: true,
            grid: { display: false }
          }
        }
      },
      plugins: [ChartDataLabels]
    });
  }


//初手事故率
  function calcBadHandRate(deck, mulliganCount = 4) {
    const trials = 1000;
    let badCount = 0;
    const deckSize = deck.length;

    for (let i = 0; i < trials; i++) {
      const shuffled = [...deck].sort(() => Math.random() - 0.5);

      const hand1 = shuffled.slice(0, 4);
      const unplayable = hand1.filter(card => parseInt(card.cost) > 4);

      if (unplayable.length < 4) continue;

      const keepCount = 4 - mulliganCount;
      const keptCards = hand1.slice(0, keepCount);
      const remainingDeck = shuffled.slice(4);
      const drawn = remainingDeck.slice(0, mulliganCount);
      const finalHand = keptCards.concat(drawn);

      const hasPlayable = finalHand.some(card => parseInt(card.cost) <= 4);
      if (!hasPlayable) badCount++;
    }

    return (badCount / trials) * 100;
  }
    function updateAccidentRateOnly() {
      const deck = currentDeck;
      const mulliganCount = parseInt(document.getElementById("mulligan-count").value);
      const accidentRate = calcBadHandRate(deck, mulliganCount);

      document.getElementById("bad-hand-rate").textContent =
        accidentRate.toFixed(1) + "%";

      // 何回に1回の表示
      const frequency = 100 / accidentRate;
      const frequencyText =
        accidentRate > 0.0 && frequency <= 100
          ? `（約${Math.round(frequency)}回に1回）`
          : "（ほぼ事故なし）";


      document.getElementById("bad-hand-frequency").textContent = frequencyText;
    }


      document.getElementById("mulligan-count").addEventListener("change", () => {
        updateAccidentRateOnly();
      });






//交換ポイント（ダイヤ・砂）
  function showExchange(type) {
    document.getElementById("exchange-point").style.display = type === "point" ? "" : "none";
    document.getElementById("exchange-diamond").style.display = type === "diamond" ? "" : "none";
    document.getElementById("exchange-sand").style.display = type === "sand" ? "" : "none";
  }

  function toggleDeckSummary() {
    const summary = document.getElementById('deck-summary');
    summary.classList.toggle('open');
  }

  //ポイントボタン切り替え
    let exchangeMode = "point"; // 初期はポイント

    function toggleExchange() {
      const modes = ["point", "diamond", "sand"];
      const labels = {
        point: "🟢 ポイント",
        diamond: "💎 ダイヤ",
        sand: "🪨 砂"
      };

      const currentIndex = modes.indexOf(exchangeMode);
      exchangeMode = modes[(currentIndex + 1) % modes.length];

      // ボタンラベル更新
      document.getElementById("exchange-toggle-btn").textContent = labels[exchangeMode];

      // 表示切り替え
      document.getElementById("exchange-point").style.display = exchangeMode === "point" ? "" : "none";
      document.getElementById("exchange-diamond").style.display = exchangeMode === "diamond" ? "" : "none";
      document.getElementById("exchange-sand").style.display = exchangeMode === "sand" ? "" : "none";
    }


  // ==========================
  // モーダル制御と戻るボタン
  // ==========================
  function closeFilterModal() {
    document.getElementById("filterModal").style.display = "none";
  }

  document.addEventListener("click", function (e) {
    const modal = document.getElementById("filterModal");

    if (e.target === modal) closeFilterModal();
  });

  document.addEventListener("keydown", function (e) {
    const modal = document.getElementById("filterModal");
    if (e.key === "Escape" && modal && modal.style.display === "flex") {
      closeFilterModal();
    }
  });

  function scrollToTop() {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  // ==========================
  // タブ切り替え
  // ==========================
  function switchTab(id) {
    // すべてのタブボタンから active を外す
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    // クリックされたタブボタンに active を付ける
    document.querySelector(`[onclick="switchTab('${id}')"]`).classList.add('active');
    // すべてのタブコンテンツを非表示
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    // 選択されたコンテンツだけ表示
    document.getElementById(id).classList.add('active');

    // 👇 追加：editタブに切り替わったときだけ実行
    if (id === "edit") {
      rebuildCardMap();
      renderDeckList();
    }
  }

//デッキ分析ボタン
  function goToAnalyzeTab() {
    switchTab('edit'); // ←ここを"edit"に確定
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }


  function updateCardDisabling() {
      const deckRaces = new Set();
      const cardCountByName = {};
      let currentOldGod = null;

      for (const [cd, count] of Object.entries(deck)) {
        const card = cardMap[cd];
        if (!card) continue;
        if (card.race !== "イノセント" && card.race !== "旧神") {
          deckRaces.add(card.race);
        }
        if (card.race === "旧神") {
          currentOldGod = card.name;
        }
        cardCountByName[card.name] = (cardCountByName[card.name] || 0) + count;
      }

    // 修正後（3種以上で制限対象とみなす）
    const raceLimitReached = deckRaces.size >= 3;

      document.querySelectorAll(".card").forEach(cardEl => {
        const cd = cardEl.dataset.cd;
        const card = cardMap[cd];
        if (!card) return;

        const isOldGodViolated = card.race === "旧神" && currentOldGod && card.name !== currentOldGod;
        const isRaceViolated = !deckRaces.has(card.race) && raceLimitReached && card.race !== "イノセント" && card.race !== "旧神";
        const isCountViolated = (cardCountByName[card.name] || 0) >= 3;


  // 使用枚数・旧神表示バッジの追加処理
  const count = deck[cd] || 0;                // デッキ内の使用枚数（0なら未使用）
  const race = card.race || "";               // 種族情報（旧神判定などに使用）

  // 古いラベルがあれば削除（再描画時に重複しないように）
  const oldLabel = cardEl.querySelector(".used-label");
  if (oldLabel) oldLabel.remove();

  // 現在旧神として使用されているcd一覧を取得
  const usedOldGodCds = Object.keys(deck).filter(c => cardMap[c]?.race === "旧神");
  const isThisOldGodUsed = usedOldGodCds.includes(cd);     // このカードが使用中の旧神か
  const isOldGodInUse = usedOldGodCds.length > 0;          // 他の旧神が使われているか

  // ラベル生成して内容を条件分岐で設定
  const label = document.createElement("div");
  label.className = "used-label";

  if (race === "旧神") {
    if (isThisOldGodUsed) {
      label.textContent = "旧神使用"; // 使用中の旧神
      cardEl.appendChild(label);
    } else if (isOldGodInUse) {
      label.textContent = "他の旧神を使用中"; // 他の旧神が使われている
      cardEl.appendChild(label);
    }
  } else {
    if (count > 0) {
      label.textContent = `使用中 ×${count}`; // 通常カードの使用数表示
      cardEl.appendChild(label);
    }
  }
});
    }



      function isCardAllowed(cd) {
        const race = document.querySelector(`.card[data-cd="${cd}"]`)?.dataset.race;
        if (!race) return true;

        const allowedRaces = new Set();
        for (const k of Object.keys(deck)) {
          const r = document.querySelector(`.card[data-cd="${k}"]`)?.dataset.race;
          if (r && !['イノセント', '旧神'].includes(r)) {
            allowedRaces.add(r);
          }
        }

        if (
          allowedRaces.size > 1 &&
          !allowedRaces.has(race) &&
          !['イノセント', '旧神'].includes(race)
        ) {
          return false;
        }

        return true;
      }


//使用不可種族表示非表示ボタン
        let hideInvalidRace = false;

        document.getElementById("toggle-invalid-race").addEventListener("click", function () {
          hideInvalidRace = !hideInvalidRace;
          this.classList.toggle("active", hideInvalidRace);
          this.textContent = hideInvalidRace ? "🚫使用不可種族を非表示" : "✅使用不可種族を表示(モノクロ)";
          applyGrayscaleFilter();
        });

          function applyGrayscaleFilter() {
            const cards = document.querySelectorAll(".card");
            cards.forEach(card => {
              const isGrayscale = card.classList.contains("grayscale");

              // 条件に合うカードにだけ非表示クラスを付与／削除
              if (hideInvalidRace && isGrayscale) {
                card.classList.add("hidden-by-grayscale");
              } else {
                card.classList.remove("hidden-by-grayscale");
              }
            });
          }



function updateGrayscaleState() {
  const usedRaces = new Set();
  for (const cd of Object.keys(deck)) {
    const race = cardMap[cd]?.race;
    if (race && !['イノセント', '旧神'].includes(race)) {
      usedRaces.add(race);
    }
  }

  const mainRace = usedRaces.size === 1 ? [...usedRaces][0] : null;

  document.querySelectorAll('.card').forEach(card => {
    const race = card.dataset.race;
    const cd = card.dataset.cd;
    const count = deck[cd] || 0;

    if (
      mainRace &&
      race &&
      !['イノセント', '旧神'].includes(race) &&
      race !== mainRace &&
      count < 3 // ← ここを追加：3枚未満のときだけモノクロにする
    ) {
      card.classList.add('grayscale');
    } else {
      card.classList.remove('grayscale');
    }
  });

}


//カード詳細情報🔎ボタン
  function handleZoomClick(event, el) {
    event.stopPropagation();
    event.preventDefault();
    const cardEl = el.closest('.card');
    expandCard(cardEl);
  }


  // デッキリスト表示（コード生成/読み込みページ用）
  function renderDeckList() {
    const container = document.getElementById("deck-card-list");


  // 🔻 empty-message を一時保持（あとで戻す）
  const emptyMessage = document.getElementById("deckcard-empty-message");

  // 🔻 一旦中身をクリア（empty-message以外）
  container.innerHTML = "";

  if (emptyMessage) container.appendChild(emptyMessage); // 消えないように戻す

    // 🔽 deck（cd → 枚数）を配列に変換
    const entries = Object.entries(deck);

    // 🔽 並び順変更の優先度定義
    const typeOrder = { "チャージャー": 0, "アタッカー": 1, "ブロッカー": 2 };

    // 🔽 並び順変更：タイプ → コスト → パワー → cd
    entries.sort((a, b) => {
      const [cdA] = a;
      const [cdB] = b;
      const cardA = cardMap[cdA];
      const cardB = cardMap[cdB];

      if (!cardA || !cardB) return 0;

      const typeA = typeOrder[cardA.type] ?? 99;
      const typeB = typeOrder[cardB.type] ?? 99;
      if (typeA !== typeB) return typeA - typeB;

      const costA = parseInt(cardA.cost) || 0;
      const costB = parseInt(cardB.cost) || 0;
      if (costA !== costB) return costA - costB;

      const powerA = parseInt(cardA.power) || 0;
      const powerB = parseInt(cardB.power) || 0;
      if (powerA !== powerB) return powerA - powerB;

      return cdA.localeCompare(cdB); // 最後にcd順
    });

    // 🔽 並び替えられた順に表示
    for (const [cd, count] of entries) {
      const card = cardMap[cd];
      if (!card) continue;

      // ▼ カード要素生成
      const cardEl = document.createElement("div");
      cardEl.className = "deck-entry";
      cardEl.dataset.cd = cd;
      cardEl.dataset.race = card.race;
      cardEl.dataset.type = card.type;
      cardEl.dataset.rarity = card.rarity || "";

      // ▼ 画像設定
      const img = document.createElement("img");
      img.src = `img/${cd.slice(0, 5)}.webp`; // 5桁IDで画像読み込み
      img.alt = card.name;
      cardEl.appendChild(img);

      // ▼ 枚数バッジ（×1など）
      const badge = document.createElement("div");
      badge.className = "count-badge";
      badge.textContent = `×${count}`;
      cardEl.appendChild(badge);

      container.appendChild(cardEl);
      cardEl.addEventListener("click", () => {
        representativeCd = cd;
        updateRepresentativeHighlight(); // 枠を付ける
        updateDeckSummaryDisplay();     // デッキ情報欄にカード名を表示（次の工程）
      });
    }
    if (!representativeCd && entries.length > 0) {
      representativeCd = entries[0][0]; // 最初のcdを代表カードに
    }
    updateRepresentativeHighlight();
    updateDeckSummaryDisplay();
    updateDeckEmptyMessage();
  }

//代表カード
  function updateRepresentativeHighlight() {
    document.querySelectorAll(".deck-entry").forEach(el => {
      el.classList.remove("representative");
      if (el.dataset.cd === representativeCd) {
        el.classList.add("representative");
      }
    });
  }


  //デッキリスト「デッキをここに表示」
  function updateDeckEmptyMessage() {
    const deck = document.getElementById("deck-card-list");
    const msg = document.getElementById("deckcard-empty-message");
    if (!deck || !msg) return;
    const cards = deck.querySelectorAll(".deck-entry"); // ← カードクラス名に合わせて変更

    if (cards.length === 0) {
      msg.style.display = "flex";
    } else {
      msg.style.display = "none";
    }
  }



  function updateDeckSummary(deckCards) {
      // 枚数
      document.getElementById("deck-count").textContent = deckCards.length;

      // 種族カウント
      const races = [...new Set(deckCards.map(c => c.種族))].filter(r => r !== "イノセント" && r !== "旧神");
      const raceText = [
        races[0] || "未選択",

      ]
      document.getElementById("deck-races").textContent = raceText;

      // 旧神状況
    const eldergods = deckCards.filter(c => c.種族 === "旧神");

    if (eldergods.length === 0) {
      document.getElementById("deck-eldergod").textContent = "未採用";
    } else if (eldergods.length === 1) {
      const cd = Object.keys(deck).find(cd => cardMap[cd]?.race === "旧神");
      const name = cd ? cardMap[cd]?.name || "旧神" : "旧神";
      document.getElementById("deck-eldergod").textContent = name;
    } else {
      document.getElementById("deck-eldergod").textContent = "他の旧神使用中";
    }

      // タイプごとにカウント
      const countByType = type => deckCards.filter(c => c.タイプ === type).length;
      document.getElementById("count-charger").textContent = countByType("チャージャー");
      document.getElementById("count-attacker").textContent = countByType("アタッカー");
      document.getElementById("count-blocker").textContent = countByType("ブロッカー");
    }

//代表カードデッキ情報表示
  function updateDeckSummaryDisplay() {
    const name = cardMap[representativeCd]?.name || "未選択";
    document.getElementById("deck-representative").textContent = name;
  }

//コードをカードcdと枚数に分ける工程
    function parseCdAndCount(fullCd) {
      const cd = fullCd.slice(0, 5);
      const count = parseInt(fullCd.slice(5), 10);
      return { cd, count };
    }

//同名カード制限
function checkSameNameLimit() {
  const nameCount = {};
  const errors = [];

  for (const cd in deck) {
    const count = deck[cd];
    const card = cardMap[cd];
    if (!card) continue;

    const name = card.name;
    nameCount[name] = (nameCount[name] || 0) + count;
  }

  for (const name in nameCount) {
    if (nameCount[name] > 3) {
      errors.push(`「${name}」は同じカードを3枚までしか入れられません（現在：${nameCount[name]}枚）`);
    }
  }

  return errors;
}


//旧神１種１枚制限
  function checkOldGodLimit() {
    const errors = [];
    const oldGodTypes = new Set();

    for (const cd in deck) {
      const count = deck[cd];
      const card = cardMap[cd];
      if (!card) continue;

      if (card.race === "旧神") {
        oldGodTypes.add(card.name);
        if (count > 1) {
          errors.push(`・旧神「${card.name}」は1枚までです`);
        }
      }
    }

    if (oldGodTypes.size > 1) {
      errors.push("旧神カードは1種類までしか入れられません");
    }

    return errors;
  }


//メイン種族制限
  function checkRaceLimit() {
    const errors = [];
    const raceSet = new Set();

    for (const cd in deck) {
      const card = cardMap[cd]; // ← parseCdAndCountは不要です
      if (!card) continue;
      raceSet.add(card.race);
    }

    const mainRaces = [...raceSet].filter(r => !["イノセント", "旧神"].includes(r));
    if (mainRaces.length > 1) {
      errors.push(`使用可能な種族は1種類です（現在：${mainRaces.join("・")}）`);
    }

    return errors;
  }


//コードチェック
  function isDeckValidWithWarning() {
    const errors = [
      ...checkSameNameLimit(),
      ...checkOldGodLimit(),
      ...checkRaceLimit()
    ];

    if (errors.length > 0) {
      showToastWarning(errors);
      return false;
    }

    return true;
  }


  //エラー表示
  function showToastWarning(messages) {
    const toast = document.getElementById("toast-warning");
    if (!toast) return;

    toast.innerHTML = "⚠️デッキ制限違反<br>" + messages.map(msg => "●" + msg).join("<br>");
    toast.style.display = "block";

    setTimeout(() => {
      toast.style.display = "none";
    }, 4000);
  }


    // 📤 コード生成（コピー）
    document.getElementById("generate-code-btn").addEventListener("click", function () {
      const code = generateDeckCode(); // デッキコード生成関数

      if (!code) {
        return; // ← コピーもメッセージも行わない
      }

      navigator.clipboard.writeText(code).then(() => {
        showCopyMessage();
      }).catch(err => {
        alert("コピーに失敗しました");
        hideCopyMessage(); // ← 失敗時にボタン文言を戻す（下で定義）
      });
    });


    //コード生成ボタン変化
    function showCopyMessage() {
      const btn = document.getElementById("generate-code-btn");
      if (!btn) return;

      const original = btn.textContent;
      btn.textContent = "✅ 生成完了";

      setTimeout(() => {
        btn.textContent = original;
      }, 1500); // 1.5秒後に元に戻す
    }


    // 📥 コード読み込み（クリップボードから直接）
    document.getElementById("load-code-btn").addEventListener("click", async function () {
      try {
        const code = await navigator.clipboard.readText();
        if (!code) {
          // 何もコピーされていないときは通知しない
          console.warn("⚠️ クリップボードが空です");
          return;
        }

        const result = loadDeckFromCode(code.trim());

        if (result === "invalid") {
          alert("デッキコードが無効です"); // これは表示したいなら残す
        } else if (result === "rule_violation") {
          // 制限違反の alert は loadDeckFromCode 側で出すのでここでは何もしない
        } else if (result === "success") {
          alert("デッキを復元しました！");
        }
      } catch (err) {
        // ⚠️ エラーは console に出すだけで、alert はしない
        console.error("📛 クリップボード読み取りエラー:", err);
      }
    });


//デッキコード生成処理
    function generateDeckCode() {

      if (Object.keys(deck).length === 0) return "";

      // 使用種族を抽出（イノセント・旧神を除く）
      const validMainRaces = ["ドラゴン", "アンドロイド", "エレメンタル", "ルミナス", "シェイド"];
      const mainRace = Object.keys(deck)
        .map(cd => cardMap[cd]?.race)
        .find(r => validMainRaces.includes(r)) || "ドラゴン";

      const raceCodeMap = {
        "ドラゴン": 1,
        "アンドロイド": 2,
        "エレメンタル": 3,
        "ルミナス": 4,
        "シェイド": 5
      };
      const g = raceCodeMap[mainRace] || 1;

      // カード構成（8桁：5桁cd + 3桁枚数）
      const cdList = Object.entries(deck).map(([cd, count]) => {
        const paddedCount = String(count).padStart(3, "0");
        return cd + paddedCount;
      });

      // 🔸 制限違反チェック
      if (!isDeckValidWithWarning()) {
        Object.keys(deck).forEach(k => delete deck[k]);
        return ;
      }

      // 代表カード（cdの最初を代表とする）
      const m = representativeCd ? representativeCd.slice(0, 5) : "00000";


      // デッキ名（未入力なら省略）
      const name = document.getElementById("deck-name")?.value.trim();
      const obj = { g, cd: cdList.join(","), m: parseInt(m) };
      if (name) obj.n = name;

      return JSON.stringify(obj).replace(
        /"n":"(.*?)"/,
        (_, raw) => `"n":"${raw.replace(/./g, c => {
          const code = c.charCodeAt(0);
          return code < 128 ? c : "\\u" + code.toString(16).padStart(4, "0");
        })}"`
      );
    }


//デッキコード読み込み処理
      function loadDeckFromCode(codeStr) {
        let obj;
        try {
          obj = JSON.parse(codeStr);
        } catch (e) {
          console.error("JSONパースエラー:", e);
          return "invalid"; // ← パース失敗
        }

        if (!obj || !obj.cd || typeof obj.cd !== "string") {
          console.warn("cd情報が無効です");
          return "invalid";
        }

        const newDeck = {};
        const parts = obj.cd.split(",");
        for (const part of parts) {
          if (!/^\d{8}$/.test(part)) {
            console.warn("形式不正:", part);
            return "invalid";
          }

          const cd = part.slice(0, 5);
          const count = parseInt(part.slice(5, 8), 10);
          if (!cardMap[cd]) {
            console.warn("存在しないカードcd:", cd);
            continue;
          }

          newDeck[cd] = count;
        }

        // デッキ更新
        Object.keys(deck).forEach(k => delete deck[k]);
        Object.assign(deck, newDeck);

        // 🔸 制限違反チェック
        if (!isDeckValidWithWarning()) {
          Object.keys(deck).forEach(k => delete deck[k]);
          return;
        }

        // 代表カード（m）の反映
        if (obj.m) {
          const repCdPrefix = String(obj.m).padStart(5, "0");
          for (const cd of Object.keys(deck)) {
            if (cd.startsWith(repCdPrefix)) {
              representativeCd = cd;
              break;
            }
          }
        }

        // デッキ名の表示も更新
        if (obj.n && document.getElementById("deck-name")) {
          document.getElementById("deck-name").value = obj.n;
        }

        updateDeck();
        updateCardDisabling();
        renderDeckList();
        updateDeckSummaryDisplay();
        return "success";
      }


//デッキ一時保存ボタン
  function saveDeckToLocalStorage() {
    // 🔸 制限違反チェック
    if (!isDeckValidWithWarning()) {
      Object.keys(deck).forEach(k => delete deck[k]);
      return ;
    }
    // デッキ名
    const deckNameInput = document.getElementById("deck-name");
    const deckName = deckNameInput ? deckNameInput.value.trim() : "名称未設定";

    // 使用種族（旧神・イノセント以外から抽出）
    const validMainRaces = ["ドラゴン", "アンドロイド", "エレメンタル", "ルミナス", "シェイド"];
    const mainRace = Object.keys(deck)
      .map(cd => cardMap[cd]?.race)
      .find(r => validMainRaces.includes(r)) || "ドラゴン";

    const raceCodeMap = {
      "ドラゴン": 1,
      "アンドロイド": 2,
      "エレメンタル": 3,
      "ルミナス": 4,
      "シェイド": 5
    };
    const g = raceCodeMap[mainRace] || 1;

    // 代表カード（最初のカードを仮に使う。別で設定している場合は representativeCd を使用）
    const m = representativeCd || Object.keys(deck)[0] || "10001";

    // 保存データ構造
    const newDeck = {
      name: deckName,
      g,
      m,
      cardCounts: { ...deck }
    };

    const MAX_SAVED_DECKS = 20;

    // 既存の保存リストを取得
    const savedList = JSON.parse(localStorage.getItem("savedDecks") || "[]");

    // 同名デッキ以外→追加
    const existingIndex = savedList.findIndex(d => d.name === deckName);

    // ✅ 上書き確認
    if (existingIndex !== -1) {
      const confirmed = confirm(`同じ名前のデッキ「${deckName}」がすでに存在します。上書きしますか？`);
      if (!confirmed) {
        alert("保存をキャンセルしました");
        return;
      }
      savedList[existingIndex] = newDeck;
    } else {
        // ✅ 上限チェック（新規保存のみ）
      if (savedList.length >= MAX_SAVED_DECKS) {
        alert("保存できるデッキは最大20件までです。不要なデッキを削除してください。");
        return;
      }

      savedList.push(newDeck);
    }

    // 保存して更新
    localStorage.setItem("savedDecks", JSON.stringify(savedList));
    updateSavedDeckList();
    alert("デッキを保存しました");

  }


//デッキリセット
  document.getElementById("resetDeckButton").addEventListener("click", () => {
    if (confirm("本当にデッキをリセットしますか？")) {
      // 🔑 デッキデータを空に
      for (const key in deck) {
        delete deck[key];
      }

      // 🔑 更新
      updateDeck();       // デッキバー＆種族など
      renderDeckList();   // デッキ詳細リスト
      // 🔑 デッキ名をリセット
      document.getElementById("deck-name").value = "";

      // 🔑 representativeCd を初期化して表示更新
      representativeCd = "";
      updateDeckSummaryDisplay();
    }
  });



//一時保存デッキリスト確認
    function updateSavedDeckList() {
      const container = document.getElementById("savedDeckList");
      const counter = document.getElementById("savedDeckCount");
      container.innerHTML = "";

      const multiSaved = JSON.parse(localStorage.getItem("savedDecks") || "[]");

        // ✅ 件数表示（20上限）
      if (counter) {
        counter.textContent = `保存デッキ数：${multiSaved.length} / 20`;
      }
      // ✅ 複数保存デッキがある場合
      if (multiSaved.length > 0) {
        multiSaved.forEach((deckData, index) => {
          // ✅ 保存日時がない場合は作る（古いデータ用）
          if (!deckData.date) {
            const today = new Date();
            const yyyy = today.getFullYear();
            const mm = String(today.getMonth() + 1).padStart(2, '0');
            const dd = String(today.getDate()).padStart(2, '0');
            deckData.date = `${yyyy}/${mm}/${dd}`;
          }

          // ✅ generateDeckLayout に渡す
          const html = generateDeckLayout(deckData, index);
          container.insertAdjacentHTML("beforeend", html);
        });
        return;
      }


      // 🔁 複数保存がなければ、旧式（tempDeck）を使う
      const singleSaved = localStorage.getItem("tempDeck");
      if (singleSaved) {
        try {
          const parsed = JSON.parse(singleSaved);
          if (parsed.cardCounts) {
            container.innerHTML = generateDeckLayout(parsed, 0);

            // ✅ 旧式保存にも件数表示（1件扱い）
            if (counter) {
              counter.textContent = `保存デッキ数：1 / 20`;
            }
            return;
          }
        } catch (e) {
          container.innerHTML = "<p style='color:red;'>保存データの読み込みに失敗しました</p>";
          return;
        }
      }

      // 🆘 どちらもない場合は仮デッキを表示
      container.innerHTML = generateDeckLayout(null);
      if (counter) {
        counter.textContent = `保存デッキ数：0 / 20`;
      }
    }


//保存デッキ表示
  function generateDeckLayout(deckData, index = null) {
    let cardImg = "img/10001.webp";
    let deckName = "デッキ一時保存（複数可）";
    let race = "リーダー種族表示";
    let count = "デッキ枚数";
    let typeCount = "チャージャー：🔵アタッカー：🟣ブロッカー：⚪️";
    let savedDate = ""; // ✅ 保存日時の初期値

    if (deckData && deckData.cardCounts) {
      // ✅ デッキ枚数・タイプ数を計算
      let total = 0, charge = 0, attack = 0, block = 0;
      for (const cd in deckData.cardCounts) {
        const n = deckData.cardCounts[cd];
        total += n;
        const card = cards.find(c => c.cd === cd);
        if (card) {
          if (card.type === "チャージャー") charge += n;
          if (card.type === "アタッカー") attack += n;
          if (card.type === "ブロッカー") block += n;
        }
      }
      count = total + "/30~40";
      typeCount = `🔵${charge}🟣${attack}⚪️${block}`;
      deckName = deckData.name || "名称未設定";
      race = getMainTribe(deckData.g);

      // ✅ 代表カード画像
      if (deckData.m) {
        cardImg = "img/" + String(deckData.m) + ".webp";
      }

      // ✅ 保存日時があれば設定（無ければ空）
      savedDate = deckData.date ? deckData.date : "";
    }

    // ✅ 読み込み・削除ボタン（複数か単一か）
    const loadBtn = index != null
      ? `<button onclick="loadDeckFromIndex(${index})">🔄 読み込む</button>`
      : `<button onclick="loadDeckFromSaved()">🔄 読み込む</button>`;

    const deleteBtn = index != null
      ? `<button onclick="deleteDeckFromIndex(${index})">🗑 削除</button>`
      : `<button onclick="clearSavedDeck()">🗑 削除</button>`;

    // ✅ 保存日時を含むHTMLを返す
    return `
    <div class="saved-deck-item">
      <img src="${cardImg}" alt="代表カード" />
      <div class="saved-deck-info">
        <div class="row">
          <strong>${deckName}</strong>
          <span>使用種族：${race}</span>
        </div>
        <div class="row">
          <span>${count}</span>
          <span>${typeCount}</span>
        </div>
        ${savedDate
        ? `<div class="row"><small>保存日時: ${savedDate}</small></div>`
        : ""
      }
      </div>
      <div class="deck-buttons">
        ${loadBtn}
        ${deleteBtn}
      </div>
    </div>
  `;
  }


//メイン種族判断
        function getMainTribe(g) {
          const tribeMap = {
            1: "ドラゴン",
            2: "アンドロイド",
            3: "エレメンタル",
            4: "ルミナス",
            5: "シェイド"
          };
          return tribeMap[g] || "？";
        }


//一時保存デッキ単体
    function loadDeckFromSaved() {
      const saved = localStorage.getItem("tempDeck");
      if (!saved) return alert("保存されたデッキがありません");

      try {
        const parsed = JSON.parse(saved);

        const deckNameInput = document.getElementById("deck-name");
        if (deckNameInput) {
          deckNameInput.value = parsed.name || "";
        }

        // ここが修正ポイント
        for (const key in deck) {
          delete deck[key];
        }
        Object.assign(deck, parsed.cardCounts);

        updateDeck();
        updateCardDisabling();
        renderDeckList()
        updateDeckSummaryDisplay();

        alert("一時保存したデッキを読み込みました");

      } catch (e) {
        alert("デッキの読み込みに失敗しました");
        console.error(e);
      }
    }

//一時保存デッキ複数
      function loadDeckFromIndex(index) {
        const savedList = JSON.parse(localStorage.getItem("savedDecks") || "[]");
        const data = savedList[index];
        if (!data) return;

        const nameInput = document.getElementById("deck-name");
        if (nameInput) nameInput.value = data.name || "";

        for (const key in deck) delete deck[key];
        Object.assign(deck, data.cardCounts);

        updateDeck();
        updateCardDisabling();
        renderDeckList();
        updateDeckSummaryDisplay();
        alert("保存されたデッキを読み込みました");
      }


//一時保存デッキ削除（単体）
    function clearSavedDeck() {
      localStorage.removeItem("tempDeck");
      updateSavedDeckList();
      alert("保存されたデッキを削除しました");
    }


//一時保存デッキ削除（複数）
  function deleteDeckFromIndex(index) {
    const savedList = JSON.parse(localStorage.getItem("savedDecks") || "[]");
    savedList.splice(index, 1);
    localStorage.setItem("savedDecks", JSON.stringify(savedList));
    updateSavedDeckList(); // 一覧を更新
  }


//タブ切り替え時一時保存リスト更新
    document.getElementById("tab-edit")?.addEventListener("click", () => {
      updateSavedDeckList();
    });


  //龍年モード表示
  const searchInput = document.getElementById('keyword'); // 検索欄のID
  const dragonButton = document.getElementById('dragon-mode-btn'); // 龍年ボタンのID

  searchInput.addEventListener('input', () => {
    const keyword = searchInput.value.trim();
    if (keyword.includes('龍年')) {
      dragonButton.style.display = 'inline-block'; // ボタン表示
    } else {
      dragonButton.style.display = 'none'; // 非表示
    }
  });


//所持カード反映ボタン
  function toggleOwned() {
    if (!isOwnedReflected) {
      const confirmed = window.confirm("所持カードを反映しますか？");
      if (confirmed) {
        isOwnedReflected = true;
        document.getElementById("toggleOwnedBtn").innerText = "所持カード反映中";
        // ここで所持率反映処理を呼ぶ予定
      }
    } else {
      // もしOFFに戻す仕様があれば
      isOwnedReflected = false;
      document.getElementById("toggleOwnedBtn").innerText = "所持カード未反映";
      // ここで所持率未反映状態に戻す処理を呼ぶ
    }
  }
</script>


</body>
</html>