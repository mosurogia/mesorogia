
<!DOCTYPE html>

<html lang="ja">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google-site-verification" content="5NzYWNH5_YUg0dUV2iCzg_bSo7M1lLJi6IzOeF2dGXM" />
    <!-- ãƒšãƒ¼ã‚¸ã®èª¬æ˜ï¼ˆæ¤œç´¢çµæœã®ä¸‹ã«è¡¨ç¤ºï¼‰ -->
    <meta name="description" content="ã“ã®ã‚µã‚¤ãƒˆã¯ã€ã‚¢ãƒ—ãƒªã€Œä¿¡è¨—ã®ãƒ¡ã‚½ãƒ­ã‚®ã‚¢ã€ã®ã‚«ãƒ¼ãƒ‰ä¸€è¦§ã€ãƒ‡ãƒƒã‚­æ§‹ç¯‰ã€ãƒ‡ãƒƒã‚­åˆ†æãŒã§ãã‚‹éå…¬å¼ã‚µã‚¤ãƒˆã§ã™ã€‚ã‚«ãƒ¼ãƒ‰æ¤œç´¢ã‚„ãƒ‡ãƒƒã‚­ç®¡ç†ã‚’ã‚¹ãƒãƒ›ã§ã‚‚å¿«é©ã«ï¼">
    <!-- ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆä»Šã¯åŠ¹æœã¯è–„ã„ãŒä¸€å¿œï¼‰ -->
    <meta name="keywords" content="ã‚«ãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ ,ãƒ‡ãƒƒã‚­ãƒ¡ãƒ¼ã‚«ãƒ¼,DCG,ç¥è¨—ã®ãƒ¡ã‚½ãƒ­ã‚®ã‚¢,ãƒ¡ã‚½ãƒ­ã‚®ã‚¢,ç¥è¨—,ãƒ‡ãƒƒã‚­åˆ†æ,ä¸€è¦§,ãƒ¢ã‚¹ãƒ­ã‚®ã‚¢">
    <!-- OGPåŸºæœ¬ -->
    <meta property="og:title" content="ãƒ¢ã‚¹ãƒ­ã‚®ã‚¢ | ç¥è¨—ã®ãƒ¡ã‚½ãƒ­ã‚®ã‚¢ ãƒ‡ãƒƒã‚­ãƒ¡ãƒ¼ã‚«ãƒ¼">
    <meta property="og:description" content="ã“ã®ã‚µã‚¤ãƒˆã¯ã‚¢ãƒ—ãƒªã€Œç¥è¨—ã®ãƒ¡ã‚½ãƒ­ã‚®ã‚¢ã€ã®ã‚«ãƒ¼ãƒ‰æ¤œç´¢ãƒ»ãƒ‡ãƒƒã‚­æ§‹ç¯‰ãŒã§ãã‚‹éå…¬å¼ã‚µã‚¤ãƒˆã§ã™ã€‚">
    <meta property="og:image" content="https://mosurogia.github.io/mesorogia-cards/img/deckmakerogp.webp">
    <meta property="og:url" content="https://mosurogia.github.io/mesorogia-cards/">
    <meta property="og:type" content="website">

    <!-- Twitterã‚«ãƒ¼ãƒ‰å‘ã‘ -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ãƒ¢ã‚¹ãƒ­ã‚®ã‚¢ | ç¥è¨—ã®ãƒ¡ã‚½ãƒ­ã‚®ã‚¢ ãƒ‡ãƒƒã‚­ãƒ¡ãƒ¼ã‚«ãƒ¼">
    <meta name="twitter:description" content="ã‚«ãƒ¼ãƒ‰æ¤œç´¢ã¨ãƒ‡ãƒƒã‚­æ§‹ç¯‰ã§ä¿¡è¨—ã®ãƒ¡ã‚½ãƒ­ã‚®ã‚¢ã‚’ã‚‚ã£ã¨æ¥½ã—ã‚‚ã†ï¼">
    <meta name="twitter:image" content="https://mosurogia.github.io/mesorogia-cards/img/deckmakerogp.webp">

    <meta charset="utf-8" />
    <title>ãƒ¢ã‚¹ãƒ­ã‚®ã‚¢ ç¥è¨—ã®ãƒ¡ã‚½ãƒ­ã‚®ã‚¢ ãƒ‡ãƒƒã‚­ãƒ¡ãƒ¼ã‚«ãƒ¼</title>
<link href="favicon.ico" rel="icon" type="image/png"/>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
<style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #f5f5f5;
    }

    .main-header {
  height: 55px;
  background-image: url("img/header.webp");
  background-repeat: repeat-x;       /* æ¨ªæ–¹å‘ã«ç¹°ã‚Šè¿”ã— */
  background-size: auto 55px;        /* é«˜ã•55pxã«ãƒ•ã‚£ãƒƒãƒˆ */
  background-position: center center;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0px 5px;
  color: white;
  top: 0;
  z-index: 1000;
}

.header-logo img {
  height: 1.8em;
  width: auto;
  margin-top: 10px;
  object-fit: contain;
}

.header-nav a {
  margin-left: 1em;
  color: white;
  text-decoration: none;
  font-weight: bold;
  font-size: 0.85em;
  background-color: rgba(0, 0, 0, 0.4);
  padding: 6px 0.2em;
  border-radius: 6px;
  transition: background-color 0.3s;
}

.header-nav a:hover {
  background-color: rgba(255, 255, 255, 0.2);  /* è»½ã„ãƒ›ãƒãƒ¼åŠ¹æœ */
  text-decoration: none;
}

    .tab-bar {
      display: flex;
      background: #333;
      color: white;
    }
    .tab {

      flex: 1;
      padding: 10px 2vw;
      text-align: center;
      cursor: pointer;
      border-bottom: 3px solid transparent;
    }
    .tab span {
      background: rgba(0, 0, 0, 0.4); /* èƒŒæ™¯ã®é»’åŠé€æ˜ */
      border-radius: 6px;
      display: inline-block;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      font-size: clamp(17px, 4.5vw, 35px);
    }
.tab:not(.active):hover span {
  background-color: rgba(255, 230, 150, 0.6);  /* æ˜ã‚‹ã‚ã«å¤‰åŒ– */
  transition: background 0.3s;
}

    .tab.active {
      border-bottom: 3px solid yellow;
      background: #444;
    }
    .tab-content {
      display: none;
      padding: 8px;
    }
    .tab-content.active {
      display: block;
    }
#tab1 {
  background-image: url("img/tab1.2.webp");
  background-size: cover;
  background-position: center;
  color: white;
  text-shadow: 1px 1px 2px black;
}

#tab2 {
  background-image: url("img/tab2.webp");
  background-size: cover;
  background-position: center;
  color: white;
  text-shadow: 1px 1px 2px black;
}
    .fixed-top-bar{
      position: sticky;
      top: 0px;
      background: #fff;
      z-index: 100;
      border-bottom: 1px solid #ccc;
    }
    .search-bar{
      position: sticky;
      top: 0px;
      background: #fff;
      z-index: 100;
      display: flex;
      gap: 1rem;
      padding: 8px;
      border-bottom: 1px solid #ccc;
    }
    .search-bar input {
      flex: 1;
      padding: 0.5rem;
      font-size: 1rem;
      box-sizing: border-box;
    }
    select{
      font-size: 0.8rem;
    }
    #sort-select{
      max-width: 100px;
      font-size: clamp(5px, 3vw, 18px);
    }
    .deck-card {
      width: 100px;
      background: #ccc;
      border: 2px solid #666;
      position: relative;
      flex-shrink: 0;
      box-sizing: border-box;
      border-radius: 6px;
      z-index: 2000; /* â† sticky header ã‚ˆã‚Šå¤§ããï¼ */
    }
    .deck-card img {
      width: 100%;
      display: block;
    }
    .count-badge {
      position: absolute;
      top: 2px;
      right: 4px;
      background: #222;
      color: #fff;
      font-size: 15px;
      border-radius: 20px;
      padding: 1px 8px;
    }




.deck-bar-wrapper {
  display: flex;
  overflow: hidden;
}
.deck-bar-scroll {
  position: relative;
  overflow-x: auto;
  overflow-y: hidden;
  touch-action: pan-x;
  flex: 1;
}

#deckHelp {
  white-space: nowrap;
  font-size: 0.6rem;
  display: flex;
  color: #555;
  padding: 4px;
  border-radius: 6px;
  gap: 8px;
}

.deck-bar-top {
  min-height: 80px;
  display: flex;
  gap:  4px;
  padding: 4px 4px 0px 4px;
  background: #fff;
  flex-wrap: nowrap;
  align-items: flex-start;
}

.deck-bar-content {
  overflow: visible;  /* â† transform ã®é£›ã³å‡ºã—ã‚’åˆ‡ã‚‰ãªã„ï¼ */
  position: relative;
}

.deck-summary {
  width: 155px;
  text-align: right;
  font-size: 14px;
  line-height: 1.4;
  background: #fff;
  border-left: 1px solid #ccc;
  padding: 4px;
  flex-shrink: 0; /* ğŸ”‘ å›ºå®šå¹…ã¨ã—ã¦å³ã«å±…åº§ã‚‹ */
  z-index: 2001;
}
.deck-summary-toggle {
    display: none;
  }

.analyze-button-wrapper {
  margin-top: 0.3rem;
  text-align: center;
}

.analyze-button {
  background-color: #6a5acd;
  color: white;
  font-size: 0.6rem;
  padding: 6px 14px;
  border: none;
  border-radius: 16px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.analyze-button:hover {
  background-color: #5a4cb5;
}

input[type="text"] {
  font-size: 16px;
  padding: 6px 12px;
  height: 36px;
}
    .grid {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
    .card {
      width: calc(100% / 7 - 5px);
      box-sizing: border-box;
      cursor: pointer;
      position: relative;
    }
    .card img {
      width: 100%;     /* ã‚°ãƒªãƒƒãƒ‰ã‚»ãƒ«ã®å¹…ã«åˆã‚ã›ã‚‹ */
      height: auto;    /* ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒ */
      display: block;  /* ä½™ç™½ã‚’ãªãã™ */
      border-radius: 6px;
    }

    button, .card {
  touch-action: manipulation;
}
.card.grayscale img {
  filter: grayscale(100%);
  opacity: 0.5;
}
.hidden-by-grayscale {
  display: none !important;
}
    .zoom-btn {
      position: absolute;
      bottom: 4px;
      left: 4px;
      background: rgba(0,0,0,0.6);
      color: white;
      font-size: 16px;
      border-radius: 4px;
      padding: 2px 6px;
      cursor: pointer;
  z-index: 10;
  pointer-events: auto;

}

    .card.grayscale .zoom-btn {
  pointer-events: auto; /* â† ğŸ”ã‚’æœ‰åŠ¹ã« */
  z-index: 10;
  pointer-events: auto;

}

    .modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1200;
  justify-content: center;
  align-items: center;
}

.modal-content {
  background: #fff;
  padding: 20px;
  border-radius: 10px;
  max-width: 950px;
  width: 90%;
  max-height: 100%;
  overflow-y: auto;
  position: relative;
  box-sizing: border-box;
  margin: auto;

}
.filter-btn {
  margin: 4px 0px;
}

    .filter-btn.selected {
      background-color: #333;
      color: white;
    }
    .filter-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    #extra-conditions{
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    }
#filterModal {
  display: none;
  flex-direction: column;
  max-height: 120vh;
  overflow-y: auto;
}
#scrollTopFixed {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 40px;
  aspect-ratio: 1/1;
  padding: 0;
  font-size: 25px;
  background-color: #eee;
  border-radius: 50%;
  border: 1px solid #aaa;
  cursor: pointer;
  z-index: 9999;
}
/* ã‚«ãƒ¼ãƒ‰è©³ç´°ã®åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
.card-detail {
  display: none;
  width: 100%;
  padding: 1rem;
  border-radius: 6px;
  margin: 0.5rem 0;
  box-sizing: border-box;
}

/* ===== ã‚¿ã‚¤ãƒ—åˆ¥èƒŒæ™¯è‰² ===== */
.type-ã‚¢ã‚¿ãƒƒã‚«ãƒ¼ {
  background: rgba(125, 91, 155, 0.5);  /* ç´« */
}
.type-ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼ {
  background: rgba(119, 170, 212, 0.5);  /* æ°´è‰² */
}
.type-ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ {
  background: rgba(214, 212, 204, 0.5);  /* ç°è‰² */
}

/* ===== ç¨®æ—åˆ¥æ ç·šè‰² ===== */
.race-ãƒ‰ãƒ©ã‚´ãƒ³ {
  border: 6px solid rgb(200, 40, 40);
}
.race-ã‚¢ãƒ³ãƒ‰ãƒ­ã‚¤ãƒ‰ {
  border: 6px solid rgb(40, 200, 200);
}
.race-ã‚¨ãƒ¬ãƒ¡ãƒ³ã‚¿ãƒ« {
  border: 6px solid rgb(40, 180, 90);
}
.race-ãƒ«ãƒŸãƒŠã‚¹ {
  border: 6px solid rgb(240, 200, 40);
}
.race-ã‚·ã‚§ã‚¤ãƒ‰ {
  border: 6px solid rgb(150, 100, 180);
}
.race-ã‚¤ãƒã‚»ãƒ³ãƒˆ {
  border: 6px solid silver;
}
.race-æ—§ç¥ {
  border: 6px solid;
  border-image: linear-gradient(
    90deg,
    rgba(255, 255, 255, 0.6),
    rgba(255, 215, 140, 0.8),
    rgba(180, 255, 255, 0.7),
    rgba(220, 180, 255, 0.7),
    rgba(255, 255, 255, 0.6)
  ) 1;
}

/* ===== è£œè¶³è¡¨ç¤ºç”¨ ===== */
.card-name {
  font-weight: bold;
  font-size: 1.1em;
  margin-bottom: 0.3em;
}

.card-meta {
  font-size: 0.9em;
  color: #333;
  margin-bottom: 0.5em;
}

.card-effect {
  font-size: 0.95em;
  line-height: 1.5;
}

.deck-filter-bar {
  display: flex;
  justify-content: center;
  align-items: center;
}

.filter-toggle-button {
  width: 100%;
  background-color: #e0e0e0;
  color: #333;
  font-size: 0.5rem;
  padding: 2px 0px;
  border: 1px solid #aaa;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.filter-toggle-button.active {
  background-color: #6a5acd;
  color: white;
  border-color: #5a4cb5;
}

.used-label {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.6);
  color: white;
  font-weight: bold;
  font-size: 0.85em;
  text-align: center;
  z-index: 5;
}

#deck-layout {
  display: flex;
  flex-direction: column;
  gap: 0.2rem;
}

.deck-section {
  background: #fff;
  padding: 0.5rem 0px;
  border: 1px solid #ccc;
  border-radius: 6px;
  max-height: 25rem;

}

#deck-card-list {
  position: relative;
  background-image: url("img/cardlist.webp");
  background-repeat: no-repeat;
  background-size: cover;
  background-position: center;
  display: grid;
  grid-template-columns: repeat(5, 1fr); /* æ¨ª5åˆ— */
  gap: 4px; /* ã‚«ãƒ¼ãƒ‰é–“ã®éš™é–“ */
  padding: 8px;
  min-height: 140px;
  align-content: start;       /* ã‚«ãƒ¼ãƒ‰ã‚’ä¸Šè©°ã‚é…ç½® */
  justify-content: start;
  overflow-y: auto;
}
#deckcard-empty-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  opacity: 0.8;
  text-shadow: 1px 1px 2px #000;
  text-align: center;
  pointer-events: none;
  z-index: 1;
}
#deck-info{
  overflow-y: auto;
}

.deck-entry {
  position: relative;
  width: 100%;
  box-sizing: border-box;
  cursor: pointer;
}

.deck-entry img {
  width: 100%;
  height: auto;
  display: block;
  border-radius: 6px;
}
/* ä»£è¡¨ã‚«ãƒ¼ãƒ‰ã®æ ï¼ˆstyleã‚¿ã‚°ã¾ãŸã¯CSSã«è¿½åŠ ï¼‰ */
.deck-entry.representative {
  outline: 3px solid crimson;
  outline-offset: -2px;
  border-radius: 6px;
  box-shadow: 0 0 10px limegreen;
}

#analysis-section {
  max-height: 0;
  opacity: 0;
  transition: max-height 0.5s ease, opacity 0.5s ease;
}

#analysis-section.open {
  max-height: 700px; /* å¿…è¦ã«å¿œã˜ã¦èª¿æ•´ */
  opacity: 1;
}
#deck-info .deck-name-row {
  margin-bottom: 0.5rem;

}
#deck-info label {
  font-weight: bold;
  margin-right: 0.5rem;
}
#deck-info input[type="text"] {
  width: 100%;
  max-width: 240px;
  padding: 4px 8px;
  font-size: 0.65rem;
  box-sizing: border-box;
}
#deck-info div {
  font-size: 0.65rem;
  overflow-y: auto;
}
#exchange-toggle-btn{
  font-size: 0.65em;
}
#toggle-analysis-btn{
  font-size: 0.6em;
}
.deck-code-controls button{
  font-size: 0.85em;
}
.deck-type-breakdown {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem 1rem; /* è¡Œã¨åˆ—ã«å°‘ã—ä½™ç™½ */
  font-size: 0.9rem;
}

.deck-type-breakdown .type-count {
  white-space: nowrap; /* ã‚¿ã‚¤ãƒ—ã”ã¨ã«æŠ˜ã‚Šè¿”ã—ã‚’é˜²ã */
}
#savedDeckList {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); /* â¬… 2åˆ—å¯¾å¿œ */
  gap: 0.3em;
  margin-top: 0.2em;
}

.saved-deck-item {
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  gap: 0.5em;
  border: 1px solid #ccc;
  padding: 0.5em;
  background-color: #fff;
}

.saved-deck-item img {
  width: 60px;
  height: auto;
  object-fit: cover;
}

.saved-deck-info {
  flex: 1 1 200px;
  display: flex;
  flex-direction: column;
  gap: 0.25em;
  min-width: 150px;
}

.saved-deck-info .row {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5em;
}
.saved-deck-info .row small {
  font-size: 0.75em;
  color: #555;
}
.saved-deck-buttons {
  display: flex;
  flex-direction: column;
  gap: 0.5em;
  min-width: 80px;
}
#toast-warning{
  font-size: 0.65rem;
  display: none;
  position: fixed;
  top: 30px;
  left: 50%;
  transform: translateX(-50%);
  background-color: rgba(220, 53, 69, 0.95); /* Bootstrapç³»red */
  color: white;
  padding: 12px 20px;
  border-radius: 8px;
  font-weight: bold;
  z-index: 9999;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2);
}
#deck-stats {
  margin-bottom: 1.5em; /* ãƒœã‚¿ãƒ³ã¨ã®é‡ãªã‚Šã‚’é˜²ã */
}

#deck-stats .accident-rate {
  display: block;
  margin-top: 0.2em;
  font-size: 0.9em;
  color: #444;
}

footer {
  text-align: center;
  font-size: clamp(0.5rem, 1vw, 1rem);
  color: #666;
  padding: 1rem 0;
  background-color: #f9f9f9;
  line-height: 1.6;
}

footer a {
  color: #3366cc;
  text-decoration: none;
}

footer a:hover {
  text-decoration: underline;
}

@media (max-width: 1024px) {
      .card { width: calc(100% / 5 - 4px);}
    }
    @media (min-width: 700px) {
  #deck-layout {
    flex-direction: row;
    height: 100%;
    max-height: 25rem;
  }
  #deck-info {
  flex: 1;
  max-width: 50%; /* â† é©å®œèª¿æ•´å¯èƒ½ */
  min-height: 5rem;
}
#deck-card-list {
  flex: 1;
  min-width: 0;
}
}
@media (max-width: 768px) {
  .header-nav a {
  font-size: 0.75em;
}
    .card-list {
      grid-template-columns: repeat(2, 1fr); /* 2åˆ—è¡¨ç¤ºã« */
      gap: 8px;
    }

    .card {
      width: calc(100% / 4 - 4px);
      font-size: 12px;
      padding: 0px;
    }
    .deck-card {
    width: 70px;   /* ã‚¹ãƒãƒ›ã§ã¯ã“ã®ã‚µã‚¤ã‚ºã« */
    height: auto;  /* ç¸¦å¹…ã¯ç”»åƒã‚µã‚¤ã‚ºã«ä»»ã›ã‚‹ or èª¿æ•´ */
  }
  .deck-bar-wrapper {
    position: relative;
  }
  .deck-summary {
    position: absolute;
    right: 20px;
    top: 0;
    width: 110px;               /* â† çµ±åˆï¼šç‹­ã‚ã‚µã‚¤ã‚º */
    height: 100%;
    background: #fff;
    border-left: 1px solid #ccc;
    font-size: 10px;            /* â† çµ±åˆï¼šæ–‡å­—ã‚µã‚¤ã‚ºèª¿æ•´ */
    line-height: 1.3;
    transform: translateX(120%);
    transition: transform 0.3s ease;
  }
  .deck-summary.open {
    transform: translateX(0%);
  }

  .deck-summary-toggle {
    display: inline-block;
    z-index: 11;
    background: #ccc;
    border: 1px solid #999;
    border-radius: 4px 0 0 4px;
    font-size: 0.3rem;
  }
  .analyze-button {
  font-size: 0.4rem;
}
    .filter-section,
    .sort-section {
      flex-direction: column;
      gap: 6px;
    }

    .card img {
      width: 100%;
      height: auto;
    }

    .card-detail {
      font-size: 13px;
    }
    .search-bar {
    display: flex;
    gap: 3px;
    align-items: center;
    width: 100%;
    box-sizing: border-box;
    padding: 0 0rem;
  }


  .search-bar input,
  .search-bar select,
  .search-bar button {
    min-width: 0;
    box-sizing: border-box;
    padding: 0.3rem 0.5rem;
    height: 1.8rem; /* ğŸ‘ˆ ã“ã“ã§é«˜ã•ã‚’çµ±ä¸€ */
    line-height: 1.2rem;
  }

  .search-bar input {
    flex: 2;
    font-size: clamp(5px, 3vw, 18px);
    padding: 5px;
  }

  .search-bar select {
    flex: 1;
    font-size: 0.55rem;
    padding: 0.2rem;
  }

  .search-bar button {
    flex: 0 0 auto;
    font-size: clamp(5px, 2vw, 18px);
    padding: 1vw 5px;
    white-space: nowrap;
  }
  #deck-info div {
  font-size: 0.75rem;
}

  footer {
    font-size: 0.5rem; /* â† ãƒ¢ãƒã‚¤ãƒ«ã§ã¯ã•ã‚‰ã«å°ã•ã */
    padding: 0.5rem 0;
  }
  }
  @media (max-width: 680px){
  .header-nav a {
  font-size: 0.65em;
}
}
@media (max-width: 630px){
  .header-nav a {
  font-size: 0.6em;
}
}
@media (max-width: 560px){
  .header-nav a {
    margin-left: 0.1em;
  font-size: 0.45em;
}
}
@media (max-width: 410px){
  .deck-card {
    height: auto;  /* ç¸¦å¹…ã¯ç”»åƒã‚µã‚¤ã‚ºã«ä»»ã›ã‚‹ or èª¿æ•´ */
  }
  .header-nav a {
  font-size: 0.23em;
}
.deck-summary {
  width: 95px;
  font-size: 8.5px;
}
.analyze-button {
  margin-top: 0rem;
  font-size: 0.25rem;
}
}
</style>
</head>
<body>
<!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
<header class="main-header">
  <div class="header-logo">
    <img src="img/tatudosi.webp" alt="ç¥è¨—ã®ãƒ¡ã‚½ãƒ­ã‚®ã‚¢ ãƒ­ã‚´" />
  </div>
  <nav class="header-nav">
    <a href="index.html">ğŸ“– ä¸€è¦§</a>
    <a href="deckmaker.html">ğŸƒ ãƒ‡ãƒƒã‚­ãƒ¡ãƒ¼ã‚«ãƒ¼</a>
    <a href="cardcheker.html">ğŸ“Š æ‰€æŒç‡ãƒã‚§ãƒƒã‚«ãƒ¼</a>
    <a href="#" style="text-decoration: line-through; pointer-events: none; color: #aaa;">ğŸ“¤ ãƒ‡ãƒƒã‚­æŠ•ç¨¿</a>
  </nav>
</header>

<!--ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ-->
  <div class="tab-bar">
    <div id="tab1" class="tab active" onclick="switchTab('build')">
      <span>ğŸƒ ãƒ‡ãƒƒã‚­æ§‹ç¯‰</span>
    </div>
    <div id="tab2" class="tab" onclick="switchTab('edit')">
      <span>ğŸ’¾ ãƒ‡ãƒƒã‚­åˆ†æ</span>
    </div>
  </div>

<!--ãƒ‡ãƒƒã‚­æ§‹ç¯‰ã‚¿ãƒ–-->
<div class="tab-content active" id="build">

<!--ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ï¼†ãƒ‡ãƒƒã‚­ãƒãƒ¼ä¸Šéƒ¨å›ºå®šç”¨-->
<div class="fixed-top-bar">
<!--ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼-->
<div class="search-bar">
<input id="keyword" oninput="applyFilters()" placeholder="ã‚«ãƒ¼ãƒ‰æ¤œç´¢" type="text">
<button id="toggleOwnedBtn" onclick="toggleOwned()">æ‰€æŒã‚«ãƒ¼ãƒ‰æœªåæ˜ </button>
<select id="sort-select">
<option value="default">é€šå¸¸é †</option>
<option value="cost-asc">ã‚³ã‚¹ãƒˆæ˜‡é †</option>
<option value="cost-desc">ã‚³ã‚¹ãƒˆé™é †</option>
<option value="power-asc">ãƒ‘ãƒ¯ãƒ¼æ˜‡é †</option>
<option value="power-desc">ãƒ‘ãƒ¯ãƒ¼é™é †</option>
</select>
<button onclick="openFilterModal()">ğŸ“Š ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼</button>
</div>

<!--ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«-->
<div class="modal" id="filterModal">
<div class="modal-content">
<div id="main-filters">

</div>
<div>
<button onclick="toggleDetailFilters()">è©³ç´°ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é–‹é–‰</button>
<div id="detail-filters" style="display: none;">

</div>

</div>
<div style="margin-top: 1rem;">
<button id="applyFilterBtn">ã“ã®æ¡ä»¶ã§çµã‚Šè¾¼ã‚€</button>
<button onclick="resetFilters()">ãƒªã‚»ãƒƒãƒˆ</button>
</div>
</div>
</div>

<!--ãƒ‡ãƒƒã‚­ãƒãƒ¼-->
<!-- ğŸ”½ ãƒ‡ãƒƒã‚­ãƒãƒ¼å…¨ä½“ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã‚’è¿½åŠ  -->
<div class="deck-bar-wrapper">
  <div class="deck-bar-scroll">
    <div class="deck-bar-content">
      <div class="deck-bar-top" id="deckBarTop">
        <div id="deck-empty-text">
          <div style="font-size: 0.7rem;">ãƒ‡ãƒƒã‚­ãƒãƒ¼æ“ä½œ</div>
          <div class="deck-help" id="deckHelp">
            <div>
              ã€PCã€‘<br>
              ãƒ»å·¦ã‚¯ãƒªãƒƒã‚¯ï¼šè¿½åŠ <br>
              ãƒ»å³ã‚¯ãƒªãƒƒã‚¯ï¼šå‰Šé™¤<br>
            </div>
            <div>
              ã€ã‚¹ãƒãƒ›ã€‘<br>
              ãƒ»ä¸Šãƒ•ãƒªãƒƒã‚¯ï¼šè¿½åŠ <br>
              ãƒ»ä¸‹ãƒ•ãƒªãƒƒã‚¯ï¼šå‰Šé™¤
            </div>
          </div>
        </div>
        <!-- JSã§ã‚«ãƒ¼ãƒ‰ãŒä¸¦ã¶ -->
      </div>
    </div>
  </div>

  <div class="deck-summary" id="deck-summary">
    <div class="deck-info"></div>
    <div class="analyze-button-wrapper">
      <button class="analyze-button" onclick="goToAnalyzeTab()">ğŸ’¾ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ</button>
    </div>
  </div>

  <button class="deck-summary-toggle" onclick="toggleDeckSummary()">â—€</button>
</div>


<!--ä½¿ç”¨ä¸å¯ç¨®æ—è¡¨ç¤ºéè¡¨ç¤ºãƒœã‚¿ãƒ³-->
<div class="deck-filter-bar">
  <button id="toggle-invalid-race" class="filter-toggle-button">âœ…ä½¿ç”¨ä¸å¯ç¨®æ—ã‚’è¡¨ç¤º(ãƒ¢ãƒã‚¯ãƒ­)</button>
</div>
</div>

<button id="scrollTopFixed" onclick="scrollToTop()">â–²</button>

<!--ã‚«ãƒ¼ãƒ‰ä¸€è¦§-->
<div class="grid" id="grid">

<!--é¾å¹´ãƒœã‚¿ãƒ³-->

<button id="dragon-mode-btn" style="display: none;">ğŸ‰ é¾å¹´ãƒ¢ãƒ¼ãƒ‰</button>


</div>



</div>


<!--ãƒ‡ãƒƒã‚­ç·¨é›†ã‚¿ãƒ–-->
<div class="tab-content" id="edit">
  <div id="deck-layout">
<!--ãƒ‡ãƒƒã‚­ãƒªã‚¹ãƒˆã‚¾ãƒ¼ãƒ³-->
      <div id="deck-card-list" class="deck-section">
        <div id="deckcard-empty-message">ãƒ‡ãƒƒã‚­ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</div>
        <!-- ã‚«ãƒ¼ãƒ‰ä¸€è¦§ï¼ˆ5åˆ—ã‚°ãƒªãƒƒãƒ‰ï¼‰ -->
      </div>

<!--ãƒ‡ãƒƒã‚­æƒ…å ±ã‚¾ãƒ¼ãƒ³-->
      <div id="deck-info" class="deck-section">
        <h3 style="margin: 0px 0px 0.5em; font-size: 0.8em;">ãƒ‡ãƒƒã‚­æƒ…å ±</h3>
        <!-- ãƒ‡ãƒƒã‚­åå…¥åŠ›æ¬„ -->
        <div class="deck-name-row">
          <input type="text" id="deck-name" placeholder="ãƒ‡ãƒƒã‚­åã‚’å…¥åŠ›" />
        </div>

        <!-- ãƒ‡ãƒƒã‚­æšæ•° -->
        <div class="deck-count">
          ãƒ‡ãƒƒã‚­æšæ•°ï¼š<span id="deck-count">0</span> /30~40
        </div>

        <!-- ä½¿ç”¨ç¨®æ— -->
        <div class="deck-race">
          ä½¿ç”¨ç¨®æ—ï¼š<span id="deck-races">æœªé¸æŠ</span>
        </div>

        <!-- æ—§ç¥çŠ¶æ³ -->
        <div class="deck-eldergod">
          æ—§ç¥ï¼š<span id="deck-eldergod">æœªæ¡ç”¨</span>
        </div>
        <!-- ä»£è¡¨ã‚«ãƒ¼ãƒ‰ -->
        <div class="deck-representative">
          ä»£è¡¨ã‚«ãƒ¼ãƒ‰ï¼š<span id="deck-representative">æœªé¸æŠ</span>
          <div style="font-size: 14px;">ã‚¿ãƒƒãƒ—ã§å¤‰æ›´å¯èƒ½</div>
        </div>
        <!-- ä½¿ç”¨ã‚¿ã‚¤ãƒ—å†…è¨³ -->
        <div class="deck-type-breakdown">
          <span class="type-count">ğŸ”µ ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼ï¼š<span id="count-charger">0</span></span>
          <span class="type-count">ğŸŸ£ ã‚¢ã‚¿ãƒƒã‚«ãƒ¼ï¼š<span id="count-attacker">0</span></span>
          <span class="type-count">âšªï¸ï¸ï¸ï¸ï¸ ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ï¼š<span id="count-blocker">0</span></span>
        </div>
        <!--äº¤æ›ãƒã‚¤ãƒ³ãƒˆ-->
        <div class="exchange-summary" style="margin-top: 0.5rem; font-size: 0.85rem;">
          <button id="exchange-toggle-btn" onclick="toggleExchange()">ğŸŸ¢ ãƒã‚¤ãƒ³ãƒˆ</button>
          <div id="exchange-point">ğŸŸ¢ å¿…è¦ãƒã‚¤ãƒ³ãƒˆï¼š<span id="point-cost">0</span></div>
          <div id="exchange-diamond" style="display:none;">ğŸ’ å¿…è¦ãƒ€ã‚¤ãƒ¤ï¼š<span id="diamond-cost">0</span></div>
          <div id="exchange-sand" style="display:none;">
            ğŸª¨ å¿…è¦ç ‚
            <ul style="margin: 0.2rem 0 0 0.5rem;">
              <li>ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰ã®ç ‚ï¼š<span id="sand-leg">0</span>å€‹</li>
              <li>ã‚´ãƒ¼ãƒ«ãƒ‰ã®ç ‚ï¼š<span id="sand-gld">0</span>å€‹</li>
            </ul>
          </div>
          <div style="font-size: 14px;">â€»æ¡ç”¨ä¸­ã®ã‚´ãƒ¼ãƒ«ãƒ‰ã¨ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰ã‚’å…¨éƒ¨äº¤æ›ã—ãŸå ´åˆï¼ˆä»Šå¾Œæ‰€æŒã‚«ãƒ¼ãƒ‰ã‹ã‚‰åæ˜ äºˆå®šï¼‰</div>
        </div>
<!-- ğŸ”½ ãƒ‡ãƒƒã‚­åˆ†æçµæœ -->
      <button id="toggle-analysis-btn" onclick="toggleAnalysis()">ğŸ” åˆ†æã‚’è¡¨ç¤º</button>
      <div id="analysis-section" class="deck-analysis" style="margin-top: 0.5rem; font-size: 0.85rem;">
            <div>
              <strong>ãƒ¬ã‚¢ãƒªãƒ†ã‚£å†…è¨³ï¼š</strong>
              <span id="rarity-legend">ğŸŒˆ0</span> /
              <span id="rarity-gold">ğŸŸ¡ 0</span> /
              <span id="rarity-silver">âšªï¸ 0</span> /
              <span id="rarity-bronze">ğŸŸ¤ 0</span>
            </div>
            <!--ãƒ¡ã‚¤ãƒ³ç¨®æ—ãƒªã‚¹ãƒˆ-->
            <div>
              <strong>ãƒ¡ã‚¤ãƒ³ç¨®æ—ç‡ï¼š</strong>
              <span id="race-rate"> 0%</span>
            </div>
            <!--ã‚³ã‚¹ãƒˆã€ãƒ‘ãƒ¯ãƒ¼åˆ†å¸ƒã‚°ãƒ©ãƒ•-->
            <div style="max-width: 100%;">
              <strong>ã‚³ã‚¹ãƒˆåˆ†å¸ƒï¼š</strong>
              <canvas id="costChart" height="80em"></canvas>
            </div>
            <div style="max-width: 100%; margin-top: 20px;">
              <strong>ãƒ‘ãƒ¯ãƒ¼åˆ†å¸ƒï¼š</strong>
              <canvas id="powerChart" height="80em"></canvas>
            </div>
            <div>
            <!--ç·ã‚³ã‚¹ãƒˆã€ãƒ‘ãƒ¯ãƒ¼-->
              <strong>ç·ã‚³ã‚¹ãƒˆï¼š</strong><span id="total-cost">0</span>  <strong>ç·ãƒ‘ãƒ¯ãƒ¼ï¼š</strong><span id="total-power">ğŸ”µ0 / ğŸŸ£0</span>
            </div>
            <!--ãƒãƒªã‚¬ãƒ³ãƒœã‚¿ãƒ³-->
            <div>
              <label for="mulligan-count">ãƒãƒªã‚¬ãƒ³æšæ•°ï¼š</label>
              <select id="mulligan-count">
                <option value="0">ãƒãƒªã‚¬ãƒ³ãªã—</option>
                <option value="1">1æšãƒãƒªã‚¬ãƒ³</option>
                <option value="2">2æšãƒãƒªã‚¬ãƒ³</option>
                <option value="3">3æšãƒãƒªã‚¬ãƒ³</option>
                <option value="4" selected>4æšãƒãƒªã‚¬ãƒ³</option>
              </select>
              <strong>åˆæ‰‹äº‹æ•…ç‡ï¼š</strong>
              <span id="bad-hand-rate">0.0%</span>
              <span id="bad-hand-frequency">ï¼ˆã»ã¼äº‹æ•…ãªã—ï¼‰</span>
              <div style="font-size: 14px;">â€»åˆæ‰‹ã«å‡ºã›ã‚‹ã‚«ãƒ¼ãƒ‰ãŒãƒãƒªã‚¬ãƒ³ã—ã¦ã‚‚æ¥ãªã„ç¢ºç‡</div>
          </div>
        </div>
    <!-- ğŸ”½ ã‚³ãƒ¼ãƒ‰å‡ºåŠ›ãƒ»å…¥åŠ›ãƒœã‚¿ãƒ³ç¾¤ -->
    <div class="deck-code-controls">
      <button id="generate-code-btn">ğŸ“¤ ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ</button>
      <div id="copy-message" style="font-size: 0.85rem; color: green; margin-top: 0.5rem; display: none;">
        ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼ </div>
      <button id="load-code-btn">ğŸ“¥ ã‚³ãƒ¼ãƒ‰èª­ã¿è¾¼ã¿</button>
      <button onclick="saveDeckToLocalStorage()">ğŸ’¾ ä¸€æ™‚ä¿å­˜</button>
      <button id="resetDeckButton">ãƒ‡ãƒƒã‚­ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
      </div>
  </div>

<!-- ä¿å­˜ãƒ‡ãƒƒã‚­ä¸€è¦§è¡¨ç¤ºç”¨ -->
<div id="savedDeckCount" style="margin-bottom: 0.3em; font-size: 20px; color: #333;"></div>
<p style="color: red; font-weight: bold;font-size: 15px; margin: 0px;">
  âš ï¸ ãƒ‡ãƒƒã‚­ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤ã™ã‚‹ã¨ãƒ‡ãƒ¼ã‚¿ãŒæ¶ˆãˆã‚‹ã®ã§ã”æ³¨æ„ãã ã•ã„ã€‚
</p>
<div id="savedDeckList"></div>

</div>


<footer>
  <div class="site-description">
    <p>
      <strong>ãƒ¢ã‚¹ãƒ­ã‚®ã‚¢</strong> ã¯ã‚¢ãƒ—ãƒªã€ç¥è¨—ã®ãƒ¡ã‚½ãƒ­ã‚®ã‚¢ã€ã®éå…¬å¼ãƒ•ã‚¡ãƒ³ã‚µã‚¤ãƒˆã§ã™ã€‚<br>
      ã‚«ãƒ¼ãƒ‰ä¸€è¦§æ¤œç´¢ã‚„ãƒ‡ãƒƒã‚­ãƒ¡ãƒ¼ã‚«ãƒ¼ã€ãƒ‡ãƒƒã‚­åˆ†æãªã©ã‚’é€šã˜ã¦ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‘ã‘ã«ä¾¿åˆ©ãªãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ©Ÿèƒ½ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚
    </p>
  </div>

  <p>
    ğŸ”— å…¬å¼ã‚µã‚¤ãƒˆã¯ã“ã¡ã‚‰ ğŸ‘‰
    <a href="https://mythologiatheoracle.com/" target="_blank" rel="noopener noreferrer">
      ç¥è¨—ã®ãƒ¡ã‚½ãƒ­ã‚®ã‚¢å…¬å¼ã‚µã‚¤ãƒˆ
    </a>
  </p>

  Â© 2025 Mesorogia Cards. All rights reserved.<br />
  å½“ã‚µã‚¤ãƒˆã¯ã€Œç¥è¨—ã®ãƒ¡ã‚½ãƒ­ã‚®ã‚¢ã€ã®éå…¬å¼ãƒ•ã‚¡ãƒ³ã‚µã‚¤ãƒˆã§ã™ã€‚ç”»åƒãƒ»ãƒ‡ãƒ¼ã‚¿ç­‰ã®è‘—ä½œæ¨©ã¯å„æ¨©åˆ©è€…ã«å¸°å±ã—ã¾ã™ã€‚<br />
  ä¸€éƒ¨ç”»åƒç´ æã¯ã€Œã‚¸ãƒ¥ã‚¨ãƒ«ã‚»ã‚¤ãƒãƒ¼FREEã€<br />
  ï¼ˆ<a href="https://www.jewel-s.jp/" target="_blank" rel="noopener">https://www.jewel-s.jp/</a>ï¼‰ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚<br />
  ğŸ’¬ ã”è¦æœ›ãƒ»ä¸å…·åˆå ±å‘Š ğŸ‘‰
  <a href="https://x.com/192837465aruneo" target="_blank" rel="noopener noreferrer">
    @192837465aruneo
  </a>
</footer>



<div id="toast-warning" ></div>

<script>
  // ==========================
  // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
  // ==========================
  const deck = {}; // ç¾åœ¨ã®ãƒ‡ãƒƒã‚­çŠ¶æ…‹ã‚’ä¿æŒï¼ˆã‚«ãƒ¼ãƒ‰cd â†’ æšæ•°ï¼‰
let cardMap = {}; // â† ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å®šç¾©
let representativeCd = null;  // ä»£è¡¨ã‚«ãƒ¼ãƒ‰ã®cdï¼ˆ5æ¡ï¼‰
Chart.register(ChartDataLabels);
let isOwnedReflected = false;

  // âœ… JSONã‚’èª­ã¿è¾¼ã‚“ã§ã‚«ãƒ¼ãƒ‰ä¸€è¦§ï¼‹è©³ç´°ã‚’ç”Ÿæˆ
  async function loadCards() {
    const res = await fetch('/mesorogia/public/cards_latest.json');
    const cards = await res.json();

    const grid = document.getElementById('grid');
    grid.innerHTML = ''; // ä¸€æ—¦ã‚¯ãƒªã‚¢

    cards.forEach(card => {
      // --- ğŸŸ¢ ä¸€è¦§ã‚«ãƒ¼ãƒ‰ ---
      const cardDiv = document.createElement('div');
      cardDiv.classList.add('card');
      cardDiv.setAttribute('data-cd', card.cd);
      cardDiv.setAttribute('data-race', card.race);
      cardDiv.setAttribute('data-category', card.category);
      cardDiv.setAttribute('data-rarity', card.rarity);
      cardDiv.setAttribute('data-type', card.type);
      cardDiv.setAttribute('data-cost', card.cost);
      cardDiv.setAttribute('data-power', card.power);
      cardDiv.setAttribute('data-pack_name', card.pack_name);
      cardDiv.setAttribute('data-effectname', [card.effect_name1, card.effect_name2].filter(Boolean).join(','));
      cardDiv.setAttribute('data-field', card.field);
      cardDiv.setAttribute('data-BP_flag', String(card.BP_flag));
      cardDiv.setAttribute('data-special_ability', card.special_ability);
      cardDiv.setAttribute('data-destroy_opponent', String(card.destroy_opponent));
      cardDiv.setAttribute('data-draw', card.draw);
      cardDiv.setAttribute('data-graveyard_recovery', card.graveyard_recovery);
      cardDiv.setAttribute('data-cardsearch', card.cardsearch);
      cardDiv.setAttribute('data-destroy_self', card.destroy_self);
      cardDiv.setAttribute('onclick', 'expandCard(this);');

      const zoomBtn = document.createElement('div');
      zoomBtn.classList.add('zoom-btn');
      zoomBtn.innerText = 'ğŸ”';
      zoomBtn.setAttribute('onclick', 'handleZoomClick(event, this)');
      cardDiv.appendChild(zoomBtn);

      const ownedMark = document.createElement('div');
      ownedMark.classList.add('owned-mark');
      cardDiv.appendChild(ownedMark);

      const img = document.createElement('img');
      img.alt = card.name;
      img.loading = 'lazy';
      img.onclick = (e) => { e.stopPropagation(); addCard(card.cd); };
      img.src = `img/${card.cd}.webp`;
      cardDiv.appendChild(img);

      grid.appendChild(cardDiv);

      // --- ğŸŸ£ å±•é–‹è©³ç´°ã‚‚ #grid å†…ã«è¿½åŠ  ---
      const typeClass = `type-${card.type}`;
      const raceClass = `race-${card.race}`;
      const detailId = `detail-${card.cd}`;
      const effectText = [card.effect_text1, card.effect_text2].filter(Boolean).join('<br/>');

      const detailHtml = `
<div class="card-detail ${typeClass} ${raceClass}" data-name="${card.name}" id="${detailId}">
  <div class="card-name">${card.name}</div>
  <div class="card-meta">
    <span class="card-race">${card.race}</span> /
    <span class="card-category">${card.category}</span>
  </div>
  <div class="card-effect">
    ${effectText}
  </div>
</div>
    `;
      grid.insertAdjacentHTML('beforeend', detailHtml);
    });
        sortCards();
  }

//jsonèª­ã¿è¾¼ã¿ãƒ¢ãƒ¼ãƒ€ãƒ«åæ˜ 
  async function generateFilterModal() {
    const res = await fetch('/mesorogia/public/cards_latest.json');
    const cards = await res.json();

    const mainFilters = document.getElementById('main-filters');
    const detailFilters = document.getElementById('detail-filters');

    mainFilters.innerHTML = '';
    detailFilters.innerHTML = '';

    // âœ… ä¸¦ã³é †å›ºå®šï¼‹å­˜åœ¨å€¤è£œå®Œ
    const raceSet = new Set(cards.map(c => c.race));
    const races = ["ãƒ‰ãƒ©ã‚´ãƒ³", "ã‚¢ãƒ³ãƒ‰ãƒ­ã‚¤ãƒ‰", "ã‚¨ãƒ¬ãƒ¡ãƒ³ã‚¿ãƒ«", "ãƒ«ãƒŸãƒŠã‚¹", "ã‚·ã‚§ã‚¤ãƒ‰", "ã‚¤ãƒã‚»ãƒ³ãƒˆ", "æ—§ç¥"];
    raceSet.forEach(r => { if (!races.includes(r)) races.push(r); });

    const categorySet = new Set(cards.map(c => c.category));
    const categories = [
      "è–ç„”é¾ï¼ˆãƒ•ã‚©ãƒ«ãƒ†ã‚£ã‚¢ï¼‰", "ãƒ‰ãƒ©ã‚´ãƒ©ã‚¤ãƒ€ãƒ¼", "ãƒ¡ã‚¤ãƒ‰ãƒ­ãƒœ", "ã‚¢ãƒ‰ãƒŸãƒ©ãƒ«ã‚·ãƒƒãƒ—",
      "ãƒŠãƒãƒ¥ãƒªã‚¢", "é¬¼åˆ¹ï¼ˆãã›ã¤ï¼‰", "é¢¨èŠ±æ£®", "ãƒ­ã‚¹ãƒªã‚¹",
      "ç™½é¨å£«", "æ„šè€…æ„šè€…", "æ˜ãéœŠåœ’", "ãƒãƒ‡ã‚£ã‚¹ã‚­ã‚¢", "ãƒãƒ¼ã‚«ãƒ†ã‚´ãƒª"
    ];
    categorySet.forEach(c => { if (!categories.includes(c)) categories.push(c); });

    const types = ["ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼", "ã‚¢ã‚¿ãƒƒã‚«ãƒ¼", "ãƒ–ãƒ­ãƒƒã‚«ãƒ¼"];
    const rarities = ["ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰", "ã‚´ãƒ¼ãƒ«ãƒ‰", "ã‚·ãƒ«ãƒãƒ¼", "ãƒ–ãƒ­ãƒ³ã‚º"];

    const mainData = {
      "ç¨®æ—": races,
      "ã‚«ãƒ†ã‚´ãƒª": categories,
      "ã‚¿ã‚¤ãƒ—": types,
      "ãƒ¬ã‚¢ãƒªãƒ†ã‚£": rarities
    };

    Object.entries(mainData).forEach(([key, values]) => {
      const section = document.createElement('div');
      section.innerHTML = `
      <strong>${key}</strong>
      <div class="filter-group" data-key="${key}">
        ${values.map(val => `<button class="filter-btn" data-value="${val}">${val}</button>`).join('')}
      </div>
    `;
      mainFilters.appendChild(section);
    });

    // âœ… ã‚³ã‚¹ãƒˆãƒ»ãƒ‘ãƒ¯ãƒ¼
    const costs = [...new Set(cards.map(c => c.cost))].sort((a, b) => a - b);
    const powers = [...new Set(cards.map(c => c.power))].sort((a, b) => a - b);

    const costOptions = costs.map(v => `<option value="${v}">${v}</option>`).join('');
    const powerOptions = powers.map(v => `<option value="${v}">${v}</option>`).join('');

    mainFilters.insertAdjacentHTML('beforeend', `
    <br/><strong>ã‚³ã‚¹ãƒˆï¼š</strong>
    <select id="cost-min">
      <option value="">ä¸‹é™ãªã—</option>
      ${costOptions}
    </select>
    <select id="cost-max">
      <option value="">ä¸Šé™ãªã—</option>
      ${costOptions}
    </select>

    <br/><strong>ãƒ‘ãƒ¯ãƒ¼ï¼š</strong>
    <select id="power-min">
      <option value="">ä¸‹é™ãªã—</option>
      ${powerOptions}
    </select>
    <select id="power-max">
      <option value="">ä¸Šé™ãªã—</option>
      ${powerOptions}
    </select>
  `);

    // âœ… è©³ç´°ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
    const packs = [...new Set(cards.map(c => c.pack_name))];
    const effects = [...new Set(
      cards.flatMap(c => [c.effect_name1, c.effect_name2]).filter(Boolean)
    )];
    const fields = [...new Set(cards.map(c => c.field))];
    const skills = [...new Set(cards.map(c => c.special_ability))];

    const detailData = {
      "ãƒ‘ãƒƒã‚¯å": packs,
      "åŠ¹æœå": effects,
      "BPè¦ç´ ": ["true", "false"],
      "ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰": fields,
      "ç‰¹æ®ŠåŠ¹æœ": skills
    };

    Object.entries(detailData).forEach(([key, values]) => {
      const group = document.createElement('div');
      group.classList.add('filter-group');
      group.dataset.key = key;

      const label = `<div class="filter-label">${key}</div>`;
      const buttons = values.map(val => {
        // âœ… BPè¦ç´ ã®è¡¨ç¤ºã ã‘ç½®ãæ›ãˆ
        if (key === "BPè¦ç´ ") {
          return `<button class="filter-btn" data-value="${val}">${val === "true" ? "ã‚ã‚Š" : "ãªã—"}</button>`;
        }
        return `<button class="filter-btn" data-value="${val}">${val}</button>`;
      }).join('');

      group.innerHTML = label + buttons;
      detailFilters.appendChild(group);
    });

    // âœ… ãã®ä»–æ¡ä»¶ã‚’ detail-filters å†…ã«ç”Ÿæˆ
    const extraFlags = [
      { key: "draw", label: "ãƒ‰ãƒ­ãƒ¼åŠ¹æœ" },
      { key: "graveyard_recovery", label: "å¢“åœ°å›å" },
      { key: "cardsearch", label: "ã‚«ãƒ¼ãƒ‰ã‚µãƒ¼ãƒ" },
      { key: "destroy_opponent", label: "ç›¸æ‰‹ç ´å£Š" },
      { key: "destroy_self", label: "è‡ªåˆ†ç ´å£Š" }
    ];

    const extraConditions = document.createElement('div');
    extraConditions.id = 'extra-conditions';
    extraConditions.classList.add('filter-group-group');
    extraConditions.innerHTML = `<div class="filter-section-title">ãã®ä»–æ¡ä»¶</div>`;

    extraFlags.forEach(flag => {
      const group = document.createElement('div');
      group.classList.add('filter-group');
      group.dataset.key = flag;
      group.innerHTML = `<button class="filter-btn" data-value="true">${flag.label}</button>`;
      extraConditions.appendChild(group);
    });

    detailFilters.appendChild(extraConditions);
  }

    loadCards();
    generateFilterModal();





// ã‚«ãƒ¼ãƒ‰æƒ…å ±ã‚’é›†ç´„ã™ã‚‹ãƒãƒƒãƒ—ã‚’ä½œã‚‹ï¼ˆtype, race, nameï¼‰
function rebuildCardMap() {
  cardMap = {}; // ã¾ãšç©ºã®ãƒãƒƒãƒ—ã«åˆæœŸåŒ–ï¼ˆå†æ§‹ç¯‰ï¼‰

  // ç¾åœ¨è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ .card è¦ç´ ã‚’ã™ã¹ã¦èµ°æŸ»
  document.querySelectorAll('.card').forEach(card => {
    const cd = card.dataset.cd; // ã‚«ãƒ¼ãƒ‰è­˜åˆ¥IDï¼ˆ8æ¡ï¼‰
    if (!cd) return; // cdãŒãªã„è¦ç´ ã¯ç„¡è¦–

        // allCardMap ã‹ã‚‰ã‚³ãƒ”ãƒ¼ã™ã‚‹
    if (allCardMap[cd]) {
      cardMap[cd] = { ...allCardMap[cd] };
    } else {
      // ãªã‘ã‚Œã°ç›´æ¥æ§‹ç¯‰ï¼ˆå¿µã®ãŸã‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    cardMap[cd] = {
      type: card.dataset.type || "",   // ã‚¿ã‚¤ãƒ—ï¼ˆãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼ç­‰ï¼‰
      race: card.dataset.race || "",   // ç¨®æ—ï¼ˆãƒ‰ãƒ©ã‚´ãƒ³ç­‰ï¼‰
      name: card.querySelector("img")?.alt || "", // ã‚«ãƒ¼ãƒ‰åï¼ˆç”»åƒã®altå±æ€§ï¼‰

      cost: parseInt(card.dataset.cost) || 0,  // ğŸ”¹ ã‚³ã‚¹ãƒˆï¼ˆæ•´æ•°å¤‰æ›ãƒ»ãªã‘ã‚Œã°0ï¼‰
      power: parseInt(card.dataset.power) || 0, // ğŸ”¹ ãƒ‘ãƒ¯ãƒ¼ï¼ˆæ•´æ•°å¤‰æ›ãƒ»ãªã‘ã‚Œã°0ï¼‰
      rarity: card.dataset.rarity || ""
    };
  }
  });
}

  let allCardMap = {};

    function initializeAllCardMap() {
      document.querySelectorAll('.card').forEach(card => {
        const cd = card.dataset.cd;
        if (!cd) return;

        allCardMap[cd] = {
          type: card.dataset.type || "",
          race: card.dataset.race || "",
          name: card.querySelector("img")?.alt || "",
          cost: parseInt(card.dataset.cost) || 0,
          power: parseInt(card.dataset.power) || 0,
          rarity: card.dataset.rarity || ""
        };
      });

      // ğŸ”½ ã“ã‚Œã‚’è¿½åŠ 
      cards = Object.entries(allCardMap).map(([cd, data]) => ({
        cd,
        ...data
      }));
    }






  // ==========================
  // DOMèª­ã¿è¾¼ã¿å¾Œã®åˆæœŸåŒ–å‡¦ç†
  // ==========================
  document.addEventListener("DOMContentLoaded", function () {
    initializeAllCardMap();
    rebuildCardMap();
    updateSavedDeckList();



    // ãƒ‡ãƒƒã‚­ãƒãƒ¼åˆæœŸåŒ–
    const deckBarTop = document.getElementById("deckBarTop");
    // ãƒ‡ãƒƒã‚­ãƒãƒ¼å†…ã®ã‚«ãƒ¼ãƒ‰ã«å³ã‚¯ãƒªãƒƒã‚¯é˜²æ­¢å‡¦ç†ã‚’è¿½åŠ 
    document.addEventListener("contextmenu", e => {
      const deckBarTop = document.getElementById("deckBarTop");
      if (deckBarTop && deckBarTop.contains(e.target)) {
        e.preventDefault(); // ğŸ”´ deckBarTopå†…ã§ã‚ã‚Œã°å¸¸ã«æŠ‘åˆ¶
      }
    });



    // --------------------------
    // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é–¢é€£ã‚¤ãƒ™ãƒ³ãƒˆç™»éŒ²
    // --------------------------

    const keywordInput = document.getElementById("keyword");
    if (keywordInput) {
      keywordInput.addEventListener("input", applyFilters);
    }

    document.getElementById('main-filters').addEventListener("click", e => {
      if (e.target.matches('.filter-btn')) {
        e.target.classList.toggle("selected");
        applyFilters();
      }
    });


    // ã‚³ã‚¹ãƒˆãƒ»ãƒ‘ãƒ¯ãƒ¼ç¯„å›²
    document.querySelectorAll("select").forEach(select => {
      select.addEventListener("change", applyFilters);
    });

    const applyBtn = document.getElementById("applyFilterBtn");
    if (applyBtn) applyBtn.addEventListener("click", () => {
      applyFilters();
      closeFilterModal();
    });

    const resetBtn = document.getElementById("resetFilterBtn");
    if (resetBtn) resetBtn.addEventListener("click", resetFilters);

    const sortSelect = document.getElementById("sort-select");
    if (sortSelect) sortSelect.addEventListener("change", () => {
      sortCards();
      applyFilters();
    });



    // ã‚«ãƒ¼ãƒ‰è¿½åŠ é–¢æ•°ï¼ˆç”»åƒã‚¯ãƒªãƒƒã‚¯ã§ä½¿ã†ï¼‰
    window.addCard = function (cd) {
      // è©²å½“ã‚«ãƒ¼ãƒ‰ã®ç¨®æ—æƒ…å ±ã‚’å–å¾—
      const card = document.querySelector(`.card[data-cd="${cd}"]`);
      const race = card?.dataset.race || "";
      const raceType = getRaceType(race); // ğŸ”‘ ã“ã“è¿½åŠ 

      // ã™ã§ã«æ—§ç¥ãŒå…¥ã£ã¦ã„ã¦ã€é•ã†ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹
      const hasKyuushin = Object.keys(deck).some(id => {
        const r = document.querySelector(`.card[data-cd="${id}"]`)?.dataset.race;
        return r === "æ—§ç¥";
      });

      const isKyuushin = race === "æ—§ç¥";

      if (isKyuushin && hasKyuushin && !(cd in deck)) return; // ä»–ã®æ—§ç¥ãŒã„ãŸã‚‰è¿½åŠ ä¸å¯
      if ((deck[cd] || 0) >= 3) return; // 3æšåˆ¶é™
      if (isKyuushin && (deck[cd] || 0) >= 1) return; // æ—§ç¥ã¯1æšã¾ã§

      // âœ… ãƒ¡ã‚¤ãƒ³ç¨®æ—åˆ¶é™ï¼ˆæœ€å¤§1ç¨®ã¾ã§ï¼‰
      if (raceType === "main") {
        const mainRacesInDeck = Object.keys(deck)
          .map(id => {
            const r = (document.querySelector(`.card[data-cd="${id}"]`) || document.querySelector(`.deck-card[data-cd="${id}"]`))?.dataset.race;
            return getRaceType(r) === "main" ? r : null;
          })
          .filter(Boolean);

        const combined = [...mainRacesInDeck, race];
        const unique = [...new Set(combined)];

        if (unique.length > 1) return;
      }

      deck[cd] = (deck[cd] || 0) + 1;
      updateDeck();
      updateCardDisabling(); // âœ… ã“ã‚ŒãŒãªã‘ã‚Œã°ä¸€è¦§ã®æ›´æ–°ãŒã•ã‚Œãªã„
      applyGrayscaleFilter();
      applyFilters();
      checkDeckEmpty();
    }


    // ã‚«ãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯æ“ä½œï¼ˆå·¦ã‚¯ãƒªãƒƒã‚¯è¿½åŠ ã€å³ã‚¯ãƒªãƒƒã‚¯å‰Šé™¤ï¼‰
    document.querySelectorAll('.card').forEach(card => {
      const cd = card.dataset.cd;

      card.addEventListener('mousedown', e => {
        // IMG ã¾ãŸã¯ ğŸ”ï¼ˆzoom-btnï¼‰ã‚’æŠ¼ã—ãŸå ´åˆã¯ã‚«ãƒ¼ãƒ‰è¿½åŠ ã—ãªã„
        if (e.target.tagName === 'IMG' || e.target.classList.contains('zoom-btn')) return;
        handleClick(e, cd);
      });
      card.addEventListener('contextmenu', e => e.preventDefault());
    });

    sortCards();
  });


  // ==========================
  // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å‡¦ç†
  // ==========================
    // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
      function openFilterModal() {
        document.getElementById("filterModal").style.display = "flex";
        const detail = document.getElementById("detail-filters");
        if (detail) detail.style.display = "none"; // è©³ç´°ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã¯åˆæœŸçŠ¶æ…‹ã§é–‰ã˜ã‚‹

      }

      // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
      function closeFilterModal() {
        document.getElementById("filterModal").style.display = "none";
      }

      // è©³ç´°ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’ãƒˆã‚°ãƒ«
      function toggleDetailFilters() {
        const detail = document.getElementById("detail-filters");
        detail.style.display = (detail.style.display === "none") ? "block" : "none";
      }

  function applyFilters() {
    const filters = {};
    const keyword = document.getElementById("keyword").value.trim().toLowerCase();

    // âœ… JSON/dataå±æ€§ã«åˆã‚ã›ãŸãƒãƒƒãƒ—
    const attrMap = {
      "ã‚¿ã‚¤ãƒ—": "type",
      "ç¨®æ—": "race",
      "ã‚«ãƒ†ã‚´ãƒª": "category",
      "ãƒ¬ã‚¢ãƒªãƒ†ã‚£": "rarity",
      "ãƒ‘ãƒƒã‚¯å": "pack_name",       // pack â†’ pack_name ã«åˆã‚ã›ã‚‹
      "åŠ¹æœå": "effectname",
      "ç‰¹æ®ŠåŠ¹æœ": "special_ability", // skill â†’ special_ability ã«åˆã‚ã›ã‚‹
      "BPè¦ç´ ": "BP_flag",           // bp â†’ BP_flag ã«åˆã‚ã›ã‚‹
      "ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰": "field",
      "ç ´å£Š": "destroy_opponent"     // destroy â†’ destroy_opponent ã«åˆã‚ã›ã‚‹
    };

    // âœ… ãƒœã‚¿ãƒ³é¸æŠå€¤ã®åé›†
    document.querySelectorAll(".filter-group").forEach(group => {
      const key = group.getAttribute("data-key");
      const selected = Array.from(group.querySelectorAll(".filter-btn.selected"))
        .map(btn => btn.getAttribute("data-value"));
      if (selected.length > 0) filters[key] = selected;
    });

    // âœ… æ•°å€¤ç¯„å›²
    const costMin = parseIntOrNull("cost-min");
    const costMax = parseIntOrNull("cost-max");
    const powerMin = parseIntOrNull("power-min");
    const powerMax = parseIntOrNull("power-max");
    if (costMin !== null || costMax !== null) filters["ã‚³ã‚¹ãƒˆ"] = [costMin, costMax];
    if (powerMin !== null || powerMax !== null) filters["ãƒ‘ãƒ¯ãƒ¼"] = [powerMin, powerMax];

    // âœ… å„ã‚«ãƒ¼ãƒ‰ã«é©ç”¨
    document.querySelectorAll(".card").forEach(card => {
      const cd = card.getAttribute("data-cd");
      const detail = document.getElementById("detail-" + cd);
      const text = (
        card.innerText + " " +
        (detail ? detail.innerText : "") + " " +
        (card.dataset.race || "") + " " +
        (card.dataset.category || "")
      ).toLowerCase();

      let visible = true;

      for (let key in filters) {
        if (key === "ã‚³ã‚¹ãƒˆ" || key === "ãƒ‘ãƒ¯ãƒ¼") {
          const val = parseInt(card.dataset[key === "ã‚³ã‚¹ãƒˆ" ? "cost" : "power"]);
          const [min, max] = filters[key];
          if ((min !== null && val < min) || (max !== null && val > max)) {
            visible = false;
            break;
          }
          continue;
        }

        const attr = attrMap[key];
        const cardVal = card.dataset[attr] || "";

        // true/falseç³»ã®å˜ä¸€å€¤ã¯æ–‡å­—åˆ—æ¯”è¼ƒã™ã‚‹
        if (["BPè¦ç´ ", "ç ´å£Š", "ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰"].includes(key)) {
          if (!filters[key].includes(cardVal)) {
            visible = false;
            break;
          }
          continue;
        }

        // ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šãªã‚‰è¤‡æ•°æ¯”è¼ƒ
        const values = cardVal.split(",");
        const match = values.some(val => filters[key].includes(val));
        if (!match) {
          visible = false;
          break;
        }
      }

      if (keyword && !text.includes(keyword)) visible = false;

      card.style.display = visible ? "" : "none";
    });

    // å±•é–‹ä¸­ã®è©³ç´°ã‚’é–‰ã˜ã‚‹
    const active = document.querySelector(".card-detail.active");
    if (active) active.remove();

    sortCards();
    applyGrayscaleFilter();


  }



  function resetFilters() {
    document.querySelectorAll(".filter-btn.selected").forEach(btn => btn.classList.remove("selected"));
    document.querySelectorAll(".card").forEach(card => card.style.display = "");
    document.querySelectorAll("select").forEach(sel => sel.value = "");
    document.getElementById("keyword").value = "";
    document.getElementById("sort-select").value = "default";
    const active = document.querySelector(".card-detail.active");
    if (active) active.remove();
    sortCards();
  }

  function parseIntOrNull(id) {
    const el = document.getElementById(id);
    return (!el || el.value === "") ? null : parseInt(el.value);
  }

  // ==========================
  // ã‚½ãƒ¼ãƒˆå‡¦ç†
  // ==========================
  function sortCards() {
    const sortValue = document.getElementById("sort-select").value;
    const grid = document.getElementById("grid");
    const cards = Array.from(grid.children).filter(card => card.classList.contains("card"));

    const getTypeOrder = (type) => {
      if (type === "ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼") return 0;
      if (type === "ã‚¢ã‚¿ãƒƒã‚«ãƒ¼") return 1;
      if (type === "ãƒ–ãƒ­ãƒƒã‚«ãƒ¼") return 2;
      return 3;
    };

    cards.sort((a, b) => {
      const typeA = getTypeOrder(a.dataset.type);
      const typeB = getTypeOrder(b.dataset.type);
      const costA = parseInt(a.dataset.cost);
      const costB = parseInt(b.dataset.cost);
      const powerA = parseInt(a.dataset.power);
      const powerB = parseInt(b.dataset.power);
      const cdA = parseInt(a.dataset.cd);
      const cdB = parseInt(b.dataset.cd);

      switch (sortValue) {
        case "cost-asc": return costA - costB || typeA - typeB || powerA - powerB || cdA - cdB;
        case "cost-desc": return costB - costA || typeA - typeB || powerA - powerB || cdA - cdB;
        case "power-asc": return powerA - powerB || typeA - typeB || costA - costB || cdA - cdB;
        case "power-desc": return powerB - powerA || typeA - typeB || costA - costB || cdA - cdB;
        default: return typeA - typeB || costA - costB || powerA - powerB || cdA - cdB;
      }
    });

    cards.forEach(card => grid.appendChild(card));
  }

  // ==========================
  // ã‚«ãƒ¼ãƒ‰è©³ç´°å±•é–‹
  // ==========================
  function expandCard(clickedCard) {
    const cd = clickedCard.getAttribute('data-cd');
    const grid = document.getElementById('grid');
    const existing = document.querySelector('.card-detail.active');

    if (existing && existing.getAttribute('data-cd') === cd) {
      existing.remove();
      return;
    }

    if (existing) existing.remove();

    const detail = document.getElementById('detail-' + cd);
    if (!detail) return;

    const cloned = detail.cloneNode(true);
    cloned.style.display = 'block';
    cloned.classList.add('active');
    cloned.setAttribute('data-cd', cd);

    const cards = Array.from(grid.children).filter(
      c => c.classList.contains("card") && c.style.display !== "none"
    );
    const clickedIndex = cards.indexOf(clickedCard);

    let columns = 7;
    if (grid.clientWidth < 768) columns = 4;
    else if (grid.clientWidth < 1024) columns = 5;

    const rowStart = Math.floor(clickedIndex / columns) * columns;
    const rowEnd = Math.min(rowStart + columns - 1, cards.length - 1);
    const insertAfter = cards[rowEnd];
    insertAfter.insertAdjacentElement('afterend', cloned);
  }


  // ==========================
  // æŒ‡å®šã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰cdãŒæ—§ç¥ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹é–¢æ•°
  // ==========================
  function isKyuushinCard(cd) {
    const cardEl =
      document.querySelector(`.card[data-cd="${cd}"]`) ||
      document.querySelector(`.deck-card[data-cd="${cd}"]`);
    const race = cardEl?.dataset.race || "";
    return race === "æ—§ç¥";
  }


function getRaceType(race) {
  if (race === "æ—§ç¥") return "kyuushin";
  if (race === "ã‚¤ãƒã‚»ãƒ³ãƒˆ") return "innocent";
  if (["ãƒ‰ãƒ©ã‚´ãƒ³", "ã‚¢ãƒ³ãƒ‰ãƒ­ã‚¤ãƒ‰", "ã‚¨ãƒ¬ãƒ¡ãƒ³ã‚¿ãƒ«", "ãƒ«ãƒŸãƒŠã‚¹", "ã‚·ã‚§ã‚¤ãƒ‰"].includes(race)) return "main";
  return "other";
}

  // ==========================
  // ãƒ‡ãƒƒã‚­è¿½åŠ ãƒ»å‰Šé™¤ï¼ˆPCç”¨ã‚¯ãƒªãƒƒã‚¯ï¼‰
  // ==========================
  function handleClick(e, cd) {
    e.preventDefault(); // å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼é˜²æ­¢

    const cardEl = document.querySelector(`.card[data-cd="${cd}"]`) || document.querySelector(`.deck-card[data-cd="${cd}"]`);
    const race = cardEl?.dataset.race || "";
    const raceType = getRaceType(race);
    const isKyuushin = race === "æ—§ç¥";

    if (e.button === 2) {
      // å³ã‚¯ãƒªãƒƒã‚¯ â†’ æ¸›ã‚‰ã™ or å‰Šé™¤
      if (deck[cd] > 1) {
        deck[cd]--;
      } else {
        delete deck[cd];
      }

    } else {
      // å·¦ã‚¯ãƒªãƒƒã‚¯ â†’ è¿½åŠ ï¼ˆåˆ¶é™ã‚ã‚Šï¼‰
      // åŒåã‚«ãƒ¼ãƒ‰ã¯3æšã¾ã§
      if ((deck[cd] || 0) >= 3) return;

      // æ—§ç¥ã¯1ç¨®é¡1æšã¾ã§
      if (isKyuushin) {
        if ((deck[cd] || 0) >= 1) return;
        const hasOtherKyuushin = Object.keys(deck).some(id =>
          isKyuushinCard(id) && id !== cd
        );
        if (hasOtherKyuushin) return;
      }

      // ãƒ¡ã‚¤ãƒ³ç¨®æ—åˆ¶é™ï¼ˆæœ€å¤§1ç¨®ï¼‰
      if (raceType === "main") {
        const mainRacesInDeck = Object.keys(deck)
          .map(id => {
            const el = document.querySelector(`.card[data-cd="${id}"]`) || document.querySelector(`.deck-card[data-cd="${id}"]`);
            const r = el?.dataset.race || "";
            return getRaceType(r) === "main" ? r : null;
          })
          .filter(Boolean);

        const combined = [...mainRacesInDeck, race];
        const unique = [...new Set(combined)];

        if (unique.length > 1) return;
      }

      // åˆ¶é™ã‚¯ãƒªã‚¢ã—ãŸã‚‰è¿½åŠ 
      deck[cd] = (deck[cd] || 0) + 1;
    }

    // è¡¨ç¤ºæ›´æ–°
    updateDeck();
    updateCardDisabling();
    applyGrayscaleFilter();
    checkDeckEmpty();
  }


  // ãƒ‡ãƒƒã‚­ãƒãƒ¼æ›´æ–°

function isMobile() {
  return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
}


function updateDeck() {
  const deckBarTop = document.getElementById("deckBarTop");
  deckBarTop.innerHTML = '';

  //ãƒ‡ãƒƒã‚­ãƒ˜ãƒ«ãƒ—è¡¨ç¤º
    // ç©ºãƒ†ã‚­ã‚¹ãƒˆè¦ç´ ã‚’å¿…ãšæœ€åˆã«ä½œã‚‹
  const emptyText = document.createElement('div');
  emptyText.id = 'deck-empty-text';
  emptyText.innerHTML = `
      <div id="deck-empty-text">
        <div style="font-size: 0.7rem;">ãƒ‡ãƒƒã‚­ãƒãƒ¼æ“ä½œ</div>
          <div class="deck-help" id="deckHelp">
            <div>
            ã€PCã€‘<br>
            ãƒ»å·¦ã‚¯ãƒªãƒƒã‚¯ï¼šè¿½åŠ <br>
            ãƒ»å³ã‚¯ãƒªãƒƒã‚¯ï¼šå‰Šé™¤<br>
            </div>
            <div>
            ã€ã‚¹ãƒãƒ›ã€‘<br>
            ãƒ»ä¸Šãƒ•ãƒªãƒƒã‚¯ï¼šè¿½åŠ <br>
            ãƒ»ä¸‹ãƒ•ãƒªãƒƒã‚¯ï¼šå‰Šé™¤
            </div>
          </div>
      </div>
  `;

  deckBarTop.appendChild(emptyText);
  // ğŸ”½ ã‚½ãƒ¼ãƒˆå¯¾è±¡ã®deckã‚’é…åˆ—ã«å¤‰æ›
  const entries = Object.entries(deck);

  // ğŸ”½ ã‚¿ã‚¤ãƒ—é †ã«ä¸¦ã¹ã‚‹ãŸã‚ã®å„ªå…ˆåº¦è¨­å®š
  const typeOrder = { "ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼": 0, "ã‚¢ã‚¿ãƒƒã‚«ãƒ¼": 1, "ãƒ–ãƒ­ãƒƒã‚«ãƒ¼": 2 };

  // ğŸ”½ ã‚«ãƒ¼ãƒ‰ã‚’é€šå¸¸é †ï¼ˆã‚¿ã‚¤ãƒ—â†’ã‚³ã‚¹ãƒˆâ†’ãƒ‘ãƒ¯ãƒ¼â†’cdï¼‰ã«ä¸¦ã¹æ›¿ãˆ
  entries.sort((a, b) => {
    const [cdA] = a;
    const [cdB] = b;
    const cardA = cardMap[cdA];
    const cardB = cardMap[cdB];

    if (!cardA || !cardB) return 0; // æƒ…å ±ä¸è¶³ãªã‚‰é †åºç¶­æŒ

    const typeA = typeOrder[cardA.type] ?? 99;
    const typeB = typeOrder[cardB.type] ?? 99;
    if (typeA !== typeB) return typeA - typeB;

    const costA = parseInt(cardA.cost) || 0;
    const costB = parseInt(cardB.cost) || 0;
    if (costA !== costB) return costA - costB;

    const powerA = parseInt(cardA.power) || 0;
    const powerB = parseInt(cardB.power) || 0;
    if (powerA !== powerB) return powerA - powerB;

    return cdA.localeCompare(cdB); // æœ€å¾Œã«cdã§ä¸¦ã¹ã‚‹
  });

  // ğŸ”½ ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸé †ã§ãƒ‡ãƒƒã‚­ãƒãƒ¼ã«ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ç¤º
  for (const [cd, count] of entries) {
    const cardEl = document.createElement('div');
    cardEl.className = 'deck-card';
    cardEl.dataset.cd = cd;

    const race = cardMap[cd]?.race || "";
    cardEl.dataset.race = race;

    const img = document.createElement('img');
    img.src = `img/${cd.slice(0, 5)}.webp`;
    img.alt = cd;

    if (!isCardAllowed(cd)) cardEl.classList.add('grayscale');
    cardEl.appendChild(img);

    const badge = document.createElement('div');
    badge.className = 'count-badge';
    badge.textContent = count;
    cardEl.appendChild(badge);

    // ã‚¹ãƒãƒ›ã€PCã§ã®è¿½åŠ å‰Šé™¤å‡¦ç†
    if (isMobile()) {
      let touchStartX = 0;
      let touchStartY = 0;
      let dummy = null;

      cardEl.addEventListener('touchstart', e => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;

        cardEl.style.transition = '';
        cardEl.style.zIndex = '2000';
      });

      cardEl.addEventListener('touchmove', e => {
        const currentX = e.touches[0].clientX;
        const currentY = e.touches[0].clientY;

        const diffX = currentX - touchStartX;
        const diffY = currentY - touchStartY;

        if (Math.abs(diffX) > Math.abs(diffY)) return;

        let limitedDiffY = diffY;
        if (limitedDiffY > 40) limitedDiffY = 40;
        if (limitedDiffY < -40) limitedDiffY = -40;

        cardEl.style.transform = `translateY(${limitedDiffY}px)`;
      });


      cardEl.addEventListener('touchend', e => {
        const touchEndY = e.changedTouches[0].clientY;
        const diffY = touchStartY - touchEndY;
        const threshold = 20;

        cardEl.style.transition = 'transform 0.2s ease';

        const cleanUp = () => {
          cardEl.style.transform = 'translateY(0)';
          cardEl.style.zIndex = ''; // â† å¿˜ã‚Œãšæˆ»ã™
        };

        if (Math.abs(diffY) > threshold) {

          if (diffY > 0) {
            // === ä¸Šãƒ•ãƒªãƒƒã‚¯ â†’ è¿½åŠ  ===

            if (deck[cd] >= 3) {
              cleanUp();
              return;
            }

            const isOldGod = cardMap[cd]?.race === "æ—§ç¥";
            if (isOldGod) {
              const otherOldGodExists = Object.keys(deck).some(cdKey =>
                cardMap[cdKey]?.race === "æ—§ç¥" && cdKey !== cd
              );
              if (otherOldGodExists || deck[cd] >= 1) {
                cleanUp();
                return;
              }
            }

            cardEl.style.transform = 'translateY(-40px)';
            setTimeout(() => {
              cardEl.style.transition = '';
              cleanUp();

              deck[cd] = (deck[cd] || 0) + 1;
              updateDeck();
              updateCardDisabling();
              applyGrayscaleFilter();
              checkDeckEmpty();
            }, 200);

          } else {
            // === ä¸‹ãƒ•ãƒªãƒƒã‚¯ â†’ å‰Šé™¤ ===
            cardEl.style.transform = 'translateY(40px)';
            setTimeout(() => {
              cardEl.style.transition = '';
              cleanUp();

              if (deck[cd] > 1) deck[cd]--;
              else delete deck[cd];
              updateDeck();
              updateCardDisabling();
              applyGrayscaleFilter();
              checkDeckEmpty();
            }, 200);
          }

        } else {
          // === è·é›¢æœªæº€ â†’ å…ƒã«æˆ»ã™ã ã‘ ===
          setTimeout(() => {
            cardEl.style.transition = '';
            cleanUp();
            checkDeckEmpty()
          }, 200);
        }
      });

    } else {
      // PCï¼šå³ã‚¯ãƒªãƒƒã‚¯ã§å‰Šé™¤
      cardEl.addEventListener('mousedown', e => handleClick(e, cd));
      cardEl.addEventListener('contextmenu', e => e.preventDefault());
      checkDeckEmpty()
    }

    deckBarTop.appendChild(cardEl);

  }

  // ğŸ”½ ã‚µãƒãƒªãƒ¼è¡¨ç¤º
  const summary = document.getElementById("deck-summary");

  // ğŸ”½ ä¸€åº¦ä¸­èº«ã‚’å…¨éƒ¨æ¶ˆã™ã®ã§ã¯ãªãã€å¿…è¦ãªéƒ¨åˆ†ã ã‘æ¶ˆã™
  // æƒ…å ±éƒ¨åˆ†ã‚’å…¥ã‚Œã‚‹å°‚ç”¨ãƒ©ãƒƒãƒ‘ãƒ¼ã‚’æ¢ã™ã‹ã€ãªã‘ã‚Œã°ä½œã‚‹
  let info = summary.querySelector(".deck-info");
  if (!info) {
    info = document.createElement("div");
    info.className = "deck-info";
    summary.insertBefore(info, summary.firstChild); // ãƒœã‚¿ãƒ³ã®å‰ã«é…ç½®
  }

  let total = 0;
  const typeCount = { "ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼": 0, "ã‚¢ã‚¿ãƒƒã‚«ãƒ¼": 0, "ãƒ–ãƒ­ãƒƒã‚«ãƒ¼": 0 };
  const races = new Set();
  let hasOldGod = false;

  for (const [cd, count] of Object.entries(deck)) {
    const card = cardMap[cd];
    if (!card) continue;
    total += count;
    typeCount[card.type] += count;
      // ä½¿ç”¨ç¨®æ—ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆï¼ˆã‚¤ãƒã‚»ãƒ³ãƒˆãƒ»æ—§ç¥ã¯é™¤ãï¼‰
    if (card.race !== "ã‚¤ãƒã‚»ãƒ³ãƒˆ" && card.race !== "æ—§ç¥") races.add(card.race);
    if (card.race === "æ—§ç¥") hasOldGod = true;
  }

  const raceLine = "ä½¿ç”¨ç¨®æ—ï¼š" + (races.size > 0 ? Array.from(races).join("/") : "ãªã—");
  const oldGodLine = `æ—§ç¥ï¼š${hasOldGod ? "æ¡ç”¨ä¸­" : "æœªæ¡ç”¨"}`;
  const typeLine = `ğŸ”µ ${typeCount["ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼"]} ğŸŸ£ ${typeCount["ã‚¢ã‚¿ãƒƒã‚«ãƒ¼"]} âšªï¸ ${typeCount["ãƒ–ãƒ­ãƒƒã‚«ãƒ¼"]}`;

  // æ”¹è¡Œã§åˆ†ã‘ã¦è¡¨ç¤º
  info.innerHTML = `
  ãƒ‡ãƒƒã‚­æšæ•°ï¼š${total} /30~40<br>
  ${raceLine}<br>
  ${oldGodLine}<br>
  ${typeLine}
`;

  updateGrayscaleState();
  updateCardDisabling();
  // ğŸ”½ ãƒ‡ãƒƒã‚­æƒ…å ±ï¼ˆç¨®æ—ãƒ»ã‚¿ã‚¤ãƒ—ãªã©ï¼‰è¡¨ç¤ºã‚’æ›´æ–°
  const deckCards = Object.entries(deck).flatMap(([cd, count]) => {
    const card = cardMap[cd];
    if (!card) return [];
    return Array(count).fill({
      ç¨®æ—: card.race,
      ã‚¿ã‚¤ãƒ—: card.type
    });
  });
  updateDeckSummary(deckCards);
  // ğŸ”½ ãƒ‡ãƒƒã‚­é…åˆ—ã‚’ã‚«ãƒ¼ãƒ‰è©³ç´°ä»˜ãã§å±•é–‹ã—ã¦åˆ†æ
  const expandedDeck = Object.entries(deck).flatMap(([cd, count]) => {
    const card = cardMap[cd];
    if (!card) return [];
    return Array(count).fill({ ...card });
  });

  document.querySelectorAll('.deck-card').forEach(card => {
    card.addEventListener('contextmenu', e => {
      e.preventDefault(); // ğŸ”´ å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼æŠ‘åˆ¶
    });
  });
  currentDeck = expandedDeck; // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«è¨­å®šï¼ˆåˆ†æé–¢æ•°ç”¨ï¼‰
  rebuildCardMap();
  updateDeckAnalysis(); // åˆ†æå®Ÿè¡Œ
  applyFilters();
  checkDeckEmpty()
}

    //ãƒ‡ãƒƒã‚­ãƒãƒ¼èª¬æ˜è¡¨ç¤º
    function checkDeckEmpty() {
      const deckCards = document.querySelectorAll('.deck-card'); // ãƒ‡ãƒƒã‚­æ¬„ã®ã‚«ãƒ¼ãƒ‰ã‚’æ•°ãˆã‚‹
      const emptyText = document.getElementById('deck-empty-text');

      if (deckCards.length === 0) {
        emptyText.style.display = 'block';  // 1æšã‚‚ãªã‘ã‚Œã°è¡¨ç¤º
      } else {
        emptyText.style.display = 'none';   // 1æšä»¥ä¸Šã‚ã‚Œã°éè¡¨ç¤º
      }
    }


//åˆ†æè¡¨ç¤º/éè¡¨ç¤ºãƒœã‚¿ãƒ³
  function toggleAnalysis() {
    const section = document.getElementById("analysis-section");
    const btn = document.getElementById("toggle-analysis-btn");
    const isOpen = section.classList.toggle("open");
    btn.textContent = isOpen ? "â¬† åˆ†æã‚’éš ã™" : "ğŸ” åˆ†æã‚’è¡¨ç¤º";
  }


//ã‚«ãƒ¼ãƒ‰åˆ†æ
  function updateDeckAnalysis() {
    const deck = currentDeck; // ãƒ‡ãƒƒã‚­ãƒ‡ãƒ¼ã‚¿

    // åˆæœŸåŒ–
    let totalCost = 0;
    let costCount = 0; // 1ä»¥ä¸Šã®ã‚³ã‚¹ãƒˆã‚’æŒã¤ã‚«ãƒ¼ãƒ‰æ•°

    let totalChargerPower = 0;
    let chargerCount = 0;

    let totalAttackerPower = 0;
    let attackerCount = 0;
    let rarityCounts = { LEG: 0, GLD: 0, SIL: 0, BRZ: 0 };
    let raceCounts = {};

    // ã‚«ã‚¦ãƒ³ãƒˆå‡¦ç†
    deck.forEach(card => {
      const cost = Number(card.cost) || 0;
      const power = Number(card.power) || 0;
      const rarity = card.rarity || "";
      const race = card.race || "";
      const type = card.type || "";

      if (cost >= 1) {
        totalCost += cost;
        costCount++;
      }

      if (type === "ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼") {
        totalChargerPower += power;
        chargerCount++;
      } else if (type === "ã‚¢ã‚¿ãƒƒã‚«ãƒ¼") {
        totalAttackerPower += power;
        attackerCount++;
      }

      // ãƒ¬ã‚¢ãƒªãƒ†ã‚£
      if (rarity.includes("ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰")) rarityCounts.LEG++;
      else if (rarity.includes("ã‚´ãƒ¼ãƒ«ãƒ‰")) rarityCounts.GLD++;
      else if (rarity.includes("ã‚·ãƒ«ãƒãƒ¼")) rarityCounts.SIL++;
      else if (rarity.includes("ãƒ–ãƒ­ãƒ³ã‚º")) rarityCounts.BRZ++;

      // ç¨®æ—
      if (!raceCounts[race]) raceCounts[race] = 0;
      raceCounts[race]++;
    });
    updateDeckAnalysisCharts();

    // ä¸Šä½3ç¨®æ—ï¼ˆãƒ¡ã‚¤ãƒ³ç¨®æ—ï¼‰
    const sortedRaces = Object.entries(raceCounts).sort((a, b) => b[1] - a[1]);
    const mainRace = sortedRaces[0] || [0];
    const mainRate = deck.length ? Math.round((mainRace[1] / deck.length) * 100) : 0;

    // åˆæ‰‹äº‹æ•…ç‡ï¼ˆã‚³ã‚¹ãƒˆ5ä»¥ä¸Šã®ã‚«ãƒ¼ãƒ‰ãŒåˆæ‰‹8æšã«8æšã¨ã‚‚å«ã¾ã‚Œã‚‹ç¢ºç‡ï¼‰
    const mulliganCount = parseInt(document.getElementById("mulligan-count").value);
    const badRate = calcBadHandRate(deck, mulliganCount);



    // è¡¨ç¤ºæ›´æ–°
    document.getElementById("rarity-legend").textContent = `ğŸŒˆ ${rarityCounts.LEG}`;
    document.getElementById("rarity-gold").textContent = `ğŸŸ¡ ${rarityCounts.GLD}`;
    document.getElementById("rarity-silver").textContent = `âšªï¸ ${rarityCounts.SIL}`;
    document.getElementById("rarity-bronze").textContent = `ğŸŸ¤ ${rarityCounts.BRZ}`;
    document.getElementById("race-rate").textContent = `${mainRace[0]}: ${mainRate}%`;
    document.getElementById("total-cost").textContent = totalCost;
    document.getElementById("total-power").textContent = `ğŸ”µ${totalChargerPower}  ğŸŸ£${totalAttackerPower}`;
    document.getElementById("bad-hand-rate").textContent = `${badRate.toFixed(1)}%`;

    // ğŸ”½ æœªæ‰€æŒæƒ³å®šã§ã®äº¤æ›ã‚³ã‚¹ãƒˆè¨ˆç®—ï¼ˆãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰ãƒ»ã‚´ãƒ¼ãƒ«ãƒ‰ã®ã¿ï¼‰
    const legendCount = rarityCounts.LEG;
    const goldCount = rarityCounts.GLD;

    const pointCost = legendCount * 300 + goldCount * 150;
    const diamondCost = legendCount * 4000 + goldCount * 1000;
    const sandLeg = legendCount * 300;
    const sandGld = goldCount * 150;

    document.getElementById("point-cost").textContent = pointCost;
    document.getElementById("diamond-cost").textContent = diamondCost;
    document.getElementById("sand-leg").textContent = sandLeg;
    document.getElementById("sand-gld").textContent = sandGld;


  }

//ã‚³ã‚¹ãƒˆãƒ‘ãƒ¯ãƒ¼æ£’ã‚°ãƒ©ãƒ•
  let costChartInstance = null;
  let powerChartInstance = null;

  function updateDeckAnalysisCharts() {
    const deck = currentDeck; // ãƒ‡ãƒƒã‚­ã®ã‚«ãƒ¼ãƒ‰é…åˆ—
    const costCount = {};
    const powerCount = {};

    const alwaysShowCosts = [2, 4, 6, 8, 10, 12];
    const alwaysShowPowers = [0, 4, 5, 6, 7, 8, 12, 16];

    deck.forEach(card => {
      const cost = parseInt(card.cost, 10);
      const power = parseInt(card.power, 10);
      if (!isNaN(cost)) costCount[cost] = (costCount[cost] || 0) + 1;
      if (!isNaN(power)) powerCount[power] = (powerCount[power] || 0) + 1;
    });

    const costLabels = [...new Set([...alwaysShowCosts, ...Object.keys(costCount).map(Number)])].sort((a, b) => a - b);
    const costData = costLabels.map(c => costCount[c] || 0);
    const powerLabels = [...new Set([...alwaysShowPowers, ...Object.keys(powerCount).map(Number)])].sort((a, b) => a - b);
    const powerData = powerLabels.map(p => powerCount[p] || 0);

    const costCtx = document.getElementById("costChart").getContext("2d");
    const powerCtx = document.getElementById("powerChart").getContext("2d");

    if (costChartInstance) costChartInstance.destroy();
    if (powerChartInstance) powerChartInstance.destroy();

    const typeList = ['ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼', 'ã‚¢ã‚¿ãƒƒã‚«ãƒ¼', 'ãƒ–ãƒ­ãƒƒã‚«ãƒ¼'];
    const typeColors = {
      'ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼': 'rgba(119, 170, 212, 0.7)',
      'ã‚¢ã‚¿ãƒƒã‚«ãƒ¼': 'rgba(125, 91, 155, 0.7)',
      'ãƒ–ãƒ­ãƒƒã‚«ãƒ¼': 'rgba(214, 212, 204, 0.7)'
    };

    const powerTypeCount = {};
    deck.forEach(card => {
      const power = parseInt(card.power, 10);
      const type = card.type;
      if (!isNaN(power) && typeList.includes(type)) {
        if (!powerTypeCount[power]) powerTypeCount[power] = {};
        powerTypeCount[power][type] = (powerTypeCount[power][type] || 0) + 1;
      }
    });

    const powerLabelsStacked = [...new Set([...alwaysShowPowers, ...Object.keys(powerTypeCount).map(Number)])].sort((a, b) => a - b);

    const powerDatasets = typeList.map(type => ({
      label: type,
      data: powerLabelsStacked.map(p => (powerTypeCount[p] && powerTypeCount[p][type]) ? powerTypeCount[p][type] : 0),
      backgroundColor: typeColors[type],
      stack: 'stack1',
      datalabels: {
        color: '#000',
        font: { size: 10 },
        anchor: 'center',
        align: 'center',
        formatter: value => value === 0 ? '' : value
      }
    }));
    const costTypeCount = {};

    deck.forEach(card => {
      const cost = parseInt(card.cost, 10);
      const type = card.type;
      if (!isNaN(cost) && typeList.includes(type)) {
        if (!costTypeCount[cost]) costTypeCount[cost] = {};
        costTypeCount[cost][type] = (costTypeCount[cost][type] || 0) + 1;
      }
    });

    const costLabelsStacked = [...new Set([...alwaysShowCosts, ...Object.keys(costTypeCount).map(Number)])].sort((a, b) => a - b);

    const costDatasets = typeList.map(type => ({
      label: type,
      data: costLabelsStacked.map(c => (costTypeCount[c] && costTypeCount[c][type]) ? costTypeCount[c][type] : 0),
      backgroundColor: typeColors[type],
      stack: 'stack1',
      datalabels: {
        color: '#000',
        font: { size: 10 },
        anchor: 'center',
        align: 'center',
        formatter: value => value === 0 ? '' : value
      }
    }));

    costChartInstance = new Chart(costCtx, {
      type: 'bar',
      data: {
        labels: costLabelsStacked,
        datasets: costDatasets
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          tooltip: { enabled: false },
          datalabels: {
            display: true
          }
        },
        scales: {
          x: {
            stacked: true,
            grid: { display: false },
            ticks: { color: '#333', font: { size: 11 } }
          },
          y: {
            stacked: true,
            display: false,
            beginAtZero: true,
            grid: { display: false }
          }
        }
      },
      plugins: [ChartDataLabels]
    });

    powerChartInstance = new Chart(powerCtx, {
      type: 'bar',
      data: {
        labels: powerLabelsStacked,
        datasets: powerDatasets
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          tooltip: { enabled: false },
          datalabels: {
            display: true
          }
        },
        scales: {
          x: {
            stacked: true,
            grid: { display: false },
            ticks: { color: '#333', font: { size: 11 } }
          },
          y: {
            stacked: true,
            display: false,
            beginAtZero: true,
            grid: { display: false }
          }
        }
      },
      plugins: [ChartDataLabels]
    });
  }


//åˆæ‰‹äº‹æ•…ç‡
  function calcBadHandRate(deck, mulliganCount = 4) {
    const trials = 1000;
    let badCount = 0;
    const deckSize = deck.length;

    for (let i = 0; i < trials; i++) {
      const shuffled = [...deck].sort(() => Math.random() - 0.5);

      const hand1 = shuffled.slice(0, 4);
      const unplayable = hand1.filter(card => parseInt(card.cost) > 4);

      if (unplayable.length < 4) continue;

      const keepCount = 4 - mulliganCount;
      const keptCards = hand1.slice(0, keepCount);
      const remainingDeck = shuffled.slice(4);
      const drawn = remainingDeck.slice(0, mulliganCount);
      const finalHand = keptCards.concat(drawn);

      const hasPlayable = finalHand.some(card => parseInt(card.cost) <= 4);
      if (!hasPlayable) badCount++;
    }

    return (badCount / trials) * 100;
  }
    function updateAccidentRateOnly() {
      const deck = currentDeck;
      const mulliganCount = parseInt(document.getElementById("mulligan-count").value);
      const accidentRate = calcBadHandRate(deck, mulliganCount);

      document.getElementById("bad-hand-rate").textContent =
        accidentRate.toFixed(1) + "%";

      // ä½•å›ã«1å›ã®è¡¨ç¤º
      const frequency = 100 / accidentRate;
      const frequencyText =
        accidentRate > 0.0 && frequency <= 100
          ? `ï¼ˆç´„${Math.round(frequency)}å›ã«1å›ï¼‰`
          : "ï¼ˆã»ã¼äº‹æ•…ãªã—ï¼‰";


      document.getElementById("bad-hand-frequency").textContent = frequencyText;
    }


      document.getElementById("mulligan-count").addEventListener("change", () => {
        updateAccidentRateOnly();
      });






//äº¤æ›ãƒã‚¤ãƒ³ãƒˆï¼ˆãƒ€ã‚¤ãƒ¤ãƒ»ç ‚ï¼‰
  function showExchange(type) {
    document.getElementById("exchange-point").style.display = type === "point" ? "" : "none";
    document.getElementById("exchange-diamond").style.display = type === "diamond" ? "" : "none";
    document.getElementById("exchange-sand").style.display = type === "sand" ? "" : "none";
  }

  function toggleDeckSummary() {
    const summary = document.getElementById('deck-summary');
    summary.classList.toggle('open');
  }

  //ãƒã‚¤ãƒ³ãƒˆãƒœã‚¿ãƒ³åˆ‡ã‚Šæ›¿ãˆ
    let exchangeMode = "point"; // åˆæœŸã¯ãƒã‚¤ãƒ³ãƒˆ

    function toggleExchange() {
      const modes = ["point", "diamond", "sand"];
      const labels = {
        point: "ğŸŸ¢ ãƒã‚¤ãƒ³ãƒˆ",
        diamond: "ğŸ’ ãƒ€ã‚¤ãƒ¤",
        sand: "ğŸª¨ ç ‚"
      };

      const currentIndex = modes.indexOf(exchangeMode);
      exchangeMode = modes[(currentIndex + 1) % modes.length];

      // ãƒœã‚¿ãƒ³ãƒ©ãƒ™ãƒ«æ›´æ–°
      document.getElementById("exchange-toggle-btn").textContent = labels[exchangeMode];

      // è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
      document.getElementById("exchange-point").style.display = exchangeMode === "point" ? "" : "none";
      document.getElementById("exchange-diamond").style.display = exchangeMode === "diamond" ? "" : "none";
      document.getElementById("exchange-sand").style.display = exchangeMode === "sand" ? "" : "none";
    }


  // ==========================
  // ãƒ¢ãƒ¼ãƒ€ãƒ«åˆ¶å¾¡ã¨æˆ»ã‚‹ãƒœã‚¿ãƒ³
  // ==========================
  function closeFilterModal() {
    document.getElementById("filterModal").style.display = "none";
  }

  document.addEventListener("click", function (e) {
    const modal = document.getElementById("filterModal");

    if (e.target === modal) closeFilterModal();
  });

  document.addEventListener("keydown", function (e) {
    const modal = document.getElementById("filterModal");
    if (e.key === "Escape" && modal && modal.style.display === "flex") {
      closeFilterModal();
    }
  });

  function scrollToTop() {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  // ==========================
  // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
  // ==========================
  function switchTab(id) {
    // ã™ã¹ã¦ã®ã‚¿ãƒ–ãƒœã‚¿ãƒ³ã‹ã‚‰ active ã‚’å¤–ã™
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    // ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã‚¿ãƒ–ãƒœã‚¿ãƒ³ã« active ã‚’ä»˜ã‘ã‚‹
    document.querySelector(`[onclick="switchTab('${id}')"]`).classList.add('active');
    // ã™ã¹ã¦ã®ã‚¿ãƒ–ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’éè¡¨ç¤º
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    // é¸æŠã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã ã‘è¡¨ç¤º
    document.getElementById(id).classList.add('active');

    // ğŸ‘‡ è¿½åŠ ï¼šeditã‚¿ãƒ–ã«åˆ‡ã‚Šæ›¿ã‚ã£ãŸã¨ãã ã‘å®Ÿè¡Œ
    if (id === "edit") {
      rebuildCardMap();
      renderDeckList();
    }
  }

//ãƒ‡ãƒƒã‚­åˆ†æãƒœã‚¿ãƒ³
  function goToAnalyzeTab() {
    switchTab('edit'); // â†ã“ã“ã‚’"edit"ã«ç¢ºå®š
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }


  function updateCardDisabling() {
      const deckRaces = new Set();
      const cardCountByName = {};
      let currentOldGod = null;

      for (const [cd, count] of Object.entries(deck)) {
        const card = cardMap[cd];
        if (!card) continue;
        if (card.race !== "ã‚¤ãƒã‚»ãƒ³ãƒˆ" && card.race !== "æ—§ç¥") {
          deckRaces.add(card.race);
        }
        if (card.race === "æ—§ç¥") {
          currentOldGod = card.name;
        }
        cardCountByName[card.name] = (cardCountByName[card.name] || 0) + count;
      }

    // ä¿®æ­£å¾Œï¼ˆ3ç¨®ä»¥ä¸Šã§åˆ¶é™å¯¾è±¡ã¨ã¿ãªã™ï¼‰
    const raceLimitReached = deckRaces.size >= 3;

      document.querySelectorAll(".card").forEach(cardEl => {
        const cd = cardEl.dataset.cd;
        const card = cardMap[cd];
        if (!card) return;

        const isOldGodViolated = card.race === "æ—§ç¥" && currentOldGod && card.name !== currentOldGod;
        const isRaceViolated = !deckRaces.has(card.race) && raceLimitReached && card.race !== "ã‚¤ãƒã‚»ãƒ³ãƒˆ" && card.race !== "æ—§ç¥";
        const isCountViolated = (cardCountByName[card.name] || 0) >= 3;


  // ä½¿ç”¨æšæ•°ãƒ»æ—§ç¥è¡¨ç¤ºãƒãƒƒã‚¸ã®è¿½åŠ å‡¦ç†
  const count = deck[cd] || 0;                // ãƒ‡ãƒƒã‚­å†…ã®ä½¿ç”¨æšæ•°ï¼ˆ0ãªã‚‰æœªä½¿ç”¨ï¼‰
  const race = card.race || "";               // ç¨®æ—æƒ…å ±ï¼ˆæ—§ç¥åˆ¤å®šãªã©ã«ä½¿ç”¨ï¼‰

  // å¤ã„ãƒ©ãƒ™ãƒ«ãŒã‚ã‚Œã°å‰Šé™¤ï¼ˆå†æç”»æ™‚ã«é‡è¤‡ã—ãªã„ã‚ˆã†ã«ï¼‰
  const oldLabel = cardEl.querySelector(".used-label");
  if (oldLabel) oldLabel.remove();

  // ç¾åœ¨æ—§ç¥ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹cdä¸€è¦§ã‚’å–å¾—
  const usedOldGodCds = Object.keys(deck).filter(c => cardMap[c]?.race === "æ—§ç¥");
  const isThisOldGodUsed = usedOldGodCds.includes(cd);     // ã“ã®ã‚«ãƒ¼ãƒ‰ãŒä½¿ç”¨ä¸­ã®æ—§ç¥ã‹
  const isOldGodInUse = usedOldGodCds.length > 0;          // ä»–ã®æ—§ç¥ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ã‹

  // ãƒ©ãƒ™ãƒ«ç”Ÿæˆã—ã¦å†…å®¹ã‚’æ¡ä»¶åˆ†å²ã§è¨­å®š
  const label = document.createElement("div");
  label.className = "used-label";

  if (race === "æ—§ç¥") {
    if (isThisOldGodUsed) {
      label.textContent = "æ—§ç¥ä½¿ç”¨"; // ä½¿ç”¨ä¸­ã®æ—§ç¥
      cardEl.appendChild(label);
    } else if (isOldGodInUse) {
      label.textContent = "ä»–ã®æ—§ç¥ã‚’ä½¿ç”¨ä¸­"; // ä»–ã®æ—§ç¥ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹
      cardEl.appendChild(label);
    }
  } else {
    if (count > 0) {
      label.textContent = `ä½¿ç”¨ä¸­ Ã—${count}`; // é€šå¸¸ã‚«ãƒ¼ãƒ‰ã®ä½¿ç”¨æ•°è¡¨ç¤º
      cardEl.appendChild(label);
    }
  }
});
    }



      function isCardAllowed(cd) {
        const race = document.querySelector(`.card[data-cd="${cd}"]`)?.dataset.race;
        if (!race) return true;

        const allowedRaces = new Set();
        for (const k of Object.keys(deck)) {
          const r = document.querySelector(`.card[data-cd="${k}"]`)?.dataset.race;
          if (r && !['ã‚¤ãƒã‚»ãƒ³ãƒˆ', 'æ—§ç¥'].includes(r)) {
            allowedRaces.add(r);
          }
        }

        if (
          allowedRaces.size > 1 &&
          !allowedRaces.has(race) &&
          !['ã‚¤ãƒã‚»ãƒ³ãƒˆ', 'æ—§ç¥'].includes(race)
        ) {
          return false;
        }

        return true;
      }


//ä½¿ç”¨ä¸å¯ç¨®æ—è¡¨ç¤ºéè¡¨ç¤ºãƒœã‚¿ãƒ³
        let hideInvalidRace = false;

        document.getElementById("toggle-invalid-race").addEventListener("click", function () {
          hideInvalidRace = !hideInvalidRace;
          this.classList.toggle("active", hideInvalidRace);
          this.textContent = hideInvalidRace ? "ğŸš«ä½¿ç”¨ä¸å¯ç¨®æ—ã‚’éè¡¨ç¤º" : "âœ…ä½¿ç”¨ä¸å¯ç¨®æ—ã‚’è¡¨ç¤º(ãƒ¢ãƒã‚¯ãƒ­)";
          applyGrayscaleFilter();
        });

          function applyGrayscaleFilter() {
            const cards = document.querySelectorAll(".card");
            cards.forEach(card => {
              const isGrayscale = card.classList.contains("grayscale");

              // æ¡ä»¶ã«åˆã†ã‚«ãƒ¼ãƒ‰ã«ã ã‘éè¡¨ç¤ºã‚¯ãƒ©ã‚¹ã‚’ä»˜ä¸ï¼å‰Šé™¤
              if (hideInvalidRace && isGrayscale) {
                card.classList.add("hidden-by-grayscale");
              } else {
                card.classList.remove("hidden-by-grayscale");
              }
            });
          }



function updateGrayscaleState() {
  const usedRaces = new Set();
  for (const cd of Object.keys(deck)) {
    const race = cardMap[cd]?.race;
    if (race && !['ã‚¤ãƒã‚»ãƒ³ãƒˆ', 'æ—§ç¥'].includes(race)) {
      usedRaces.add(race);
    }
  }

  const mainRace = usedRaces.size === 1 ? [...usedRaces][0] : null;

  document.querySelectorAll('.card').forEach(card => {
    const race = card.dataset.race;
    const cd = card.dataset.cd;
    const count = deck[cd] || 0;

    if (
      mainRace &&
      race &&
      !['ã‚¤ãƒã‚»ãƒ³ãƒˆ', 'æ—§ç¥'].includes(race) &&
      race !== mainRace &&
      count < 3 // â† ã“ã“ã‚’è¿½åŠ ï¼š3æšæœªæº€ã®ã¨ãã ã‘ãƒ¢ãƒã‚¯ãƒ­ã«ã™ã‚‹
    ) {
      card.classList.add('grayscale');
    } else {
      card.classList.remove('grayscale');
    }
  });

}


//ã‚«ãƒ¼ãƒ‰è©³ç´°æƒ…å ±ğŸ”ãƒœã‚¿ãƒ³
  function handleZoomClick(event, el) {
    event.stopPropagation();
    event.preventDefault();
    const cardEl = el.closest('.card');
    expandCard(cardEl);
  }


  // ãƒ‡ãƒƒã‚­ãƒªã‚¹ãƒˆè¡¨ç¤ºï¼ˆã‚³ãƒ¼ãƒ‰ç”Ÿæˆ/èª­ã¿è¾¼ã¿ãƒšãƒ¼ã‚¸ç”¨ï¼‰
  function renderDeckList() {
    const container = document.getElementById("deck-card-list");


  // ğŸ”» empty-message ã‚’ä¸€æ™‚ä¿æŒï¼ˆã‚ã¨ã§æˆ»ã™ï¼‰
  const emptyMessage = document.getElementById("deckcard-empty-message");

  // ğŸ”» ä¸€æ—¦ä¸­èº«ã‚’ã‚¯ãƒªã‚¢ï¼ˆempty-messageä»¥å¤–ï¼‰
  container.innerHTML = "";

  if (emptyMessage) container.appendChild(emptyMessage); // æ¶ˆãˆãªã„ã‚ˆã†ã«æˆ»ã™

    // ğŸ”½ deckï¼ˆcd â†’ æšæ•°ï¼‰ã‚’é…åˆ—ã«å¤‰æ›
    const entries = Object.entries(deck);

    // ğŸ”½ ä¸¦ã³é †å¤‰æ›´ã®å„ªå…ˆåº¦å®šç¾©
    const typeOrder = { "ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼": 0, "ã‚¢ã‚¿ãƒƒã‚«ãƒ¼": 1, "ãƒ–ãƒ­ãƒƒã‚«ãƒ¼": 2 };

    // ğŸ”½ ä¸¦ã³é †å¤‰æ›´ï¼šã‚¿ã‚¤ãƒ— â†’ ã‚³ã‚¹ãƒˆ â†’ ãƒ‘ãƒ¯ãƒ¼ â†’ cd
    entries.sort((a, b) => {
      const [cdA] = a;
      const [cdB] = b;
      const cardA = cardMap[cdA];
      const cardB = cardMap[cdB];

      if (!cardA || !cardB) return 0;

      const typeA = typeOrder[cardA.type] ?? 99;
      const typeB = typeOrder[cardB.type] ?? 99;
      if (typeA !== typeB) return typeA - typeB;

      const costA = parseInt(cardA.cost) || 0;
      const costB = parseInt(cardB.cost) || 0;
      if (costA !== costB) return costA - costB;

      const powerA = parseInt(cardA.power) || 0;
      const powerB = parseInt(cardB.power) || 0;
      if (powerA !== powerB) return powerA - powerB;

      return cdA.localeCompare(cdB); // æœ€å¾Œã«cdé †
    });

    // ğŸ”½ ä¸¦ã³æ›¿ãˆã‚‰ã‚ŒãŸé †ã«è¡¨ç¤º
    for (const [cd, count] of entries) {
      const card = cardMap[cd];
      if (!card) continue;

      // â–¼ ã‚«ãƒ¼ãƒ‰è¦ç´ ç”Ÿæˆ
      const cardEl = document.createElement("div");
      cardEl.className = "deck-entry";
      cardEl.dataset.cd = cd;
      cardEl.dataset.race = card.race;
      cardEl.dataset.type = card.type;
      cardEl.dataset.rarity = card.rarity || "";

      // â–¼ ç”»åƒè¨­å®š
      const img = document.createElement("img");
      img.src = `img/${cd.slice(0, 5)}.webp`; // 5æ¡IDã§ç”»åƒèª­ã¿è¾¼ã¿
      img.alt = card.name;
      cardEl.appendChild(img);

      // â–¼ æšæ•°ãƒãƒƒã‚¸ï¼ˆÃ—1ãªã©ï¼‰
      const badge = document.createElement("div");
      badge.className = "count-badge";
      badge.textContent = `Ã—${count}`;
      cardEl.appendChild(badge);

      container.appendChild(cardEl);
      cardEl.addEventListener("click", () => {
        representativeCd = cd;
        updateRepresentativeHighlight(); // æ ã‚’ä»˜ã‘ã‚‹
        updateDeckSummaryDisplay();     // ãƒ‡ãƒƒã‚­æƒ…å ±æ¬„ã«ã‚«ãƒ¼ãƒ‰åã‚’è¡¨ç¤ºï¼ˆæ¬¡ã®å·¥ç¨‹ï¼‰
      });
    }
    if (!representativeCd && entries.length > 0) {
      representativeCd = entries[0][0]; // æœ€åˆã®cdã‚’ä»£è¡¨ã‚«ãƒ¼ãƒ‰ã«
    }
    updateRepresentativeHighlight();
    updateDeckSummaryDisplay();
    updateDeckEmptyMessage();
  }

//ä»£è¡¨ã‚«ãƒ¼ãƒ‰
  function updateRepresentativeHighlight() {
    document.querySelectorAll(".deck-entry").forEach(el => {
      el.classList.remove("representative");
      if (el.dataset.cd === representativeCd) {
        el.classList.add("representative");
      }
    });
  }


  //ãƒ‡ãƒƒã‚­ãƒªã‚¹ãƒˆã€Œãƒ‡ãƒƒã‚­ã‚’ã“ã“ã«è¡¨ç¤ºã€
  function updateDeckEmptyMessage() {
    const deck = document.getElementById("deck-card-list");
    const msg = document.getElementById("deckcard-empty-message");
    if (!deck || !msg) return;
    const cards = deck.querySelectorAll(".deck-entry"); // â† ã‚«ãƒ¼ãƒ‰ã‚¯ãƒ©ã‚¹åã«åˆã‚ã›ã¦å¤‰æ›´

    if (cards.length === 0) {
      msg.style.display = "flex";
    } else {
      msg.style.display = "none";
    }
  }



  function updateDeckSummary(deckCards) {
      // æšæ•°
      document.getElementById("deck-count").textContent = deckCards.length;

      // ç¨®æ—ã‚«ã‚¦ãƒ³ãƒˆ
      const races = [...new Set(deckCards.map(c => c.ç¨®æ—))].filter(r => r !== "ã‚¤ãƒã‚»ãƒ³ãƒˆ" && r !== "æ—§ç¥");
      const raceText = [
        races[0] || "æœªé¸æŠ",

      ]
      document.getElementById("deck-races").textContent = raceText;

      // æ—§ç¥çŠ¶æ³
    const eldergods = deckCards.filter(c => c.ç¨®æ— === "æ—§ç¥");

    if (eldergods.length === 0) {
      document.getElementById("deck-eldergod").textContent = "æœªæ¡ç”¨";
    } else if (eldergods.length === 1) {
      const cd = Object.keys(deck).find(cd => cardMap[cd]?.race === "æ—§ç¥");
      const name = cd ? cardMap[cd]?.name || "æ—§ç¥" : "æ—§ç¥";
      document.getElementById("deck-eldergod").textContent = name;
    } else {
      document.getElementById("deck-eldergod").textContent = "ä»–ã®æ—§ç¥ä½¿ç”¨ä¸­";
    }

      // ã‚¿ã‚¤ãƒ—ã”ã¨ã«ã‚«ã‚¦ãƒ³ãƒˆ
      const countByType = type => deckCards.filter(c => c.ã‚¿ã‚¤ãƒ— === type).length;
      document.getElementById("count-charger").textContent = countByType("ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼");
      document.getElementById("count-attacker").textContent = countByType("ã‚¢ã‚¿ãƒƒã‚«ãƒ¼");
      document.getElementById("count-blocker").textContent = countByType("ãƒ–ãƒ­ãƒƒã‚«ãƒ¼");
    }

//ä»£è¡¨ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒƒã‚­æƒ…å ±è¡¨ç¤º
  function updateDeckSummaryDisplay() {
    const name = cardMap[representativeCd]?.name || "æœªé¸æŠ";
    document.getElementById("deck-representative").textContent = name;
  }

//ã‚³ãƒ¼ãƒ‰ã‚’ã‚«ãƒ¼ãƒ‰cdã¨æšæ•°ã«åˆ†ã‘ã‚‹å·¥ç¨‹
    function parseCdAndCount(fullCd) {
      const cd = fullCd.slice(0, 5);
      const count = parseInt(fullCd.slice(5), 10);
      return { cd, count };
    }

//åŒåã‚«ãƒ¼ãƒ‰åˆ¶é™
function checkSameNameLimit() {
  const nameCount = {};
  const errors = [];

  for (const cd in deck) {
    const count = deck[cd];
    const card = cardMap[cd];
    if (!card) continue;

    const name = card.name;
    nameCount[name] = (nameCount[name] || 0) + count;
  }

  for (const name in nameCount) {
    if (nameCount[name] > 3) {
      errors.push(`ã€Œ${name}ã€ã¯åŒã˜ã‚«ãƒ¼ãƒ‰ã‚’3æšã¾ã§ã—ã‹å…¥ã‚Œã‚‰ã‚Œã¾ã›ã‚“ï¼ˆç¾åœ¨ï¼š${nameCount[name]}æšï¼‰`);
    }
  }

  return errors;
}


//æ—§ç¥ï¼‘ç¨®ï¼‘æšåˆ¶é™
  function checkOldGodLimit() {
    const errors = [];
    const oldGodTypes = new Set();

    for (const cd in deck) {
      const count = deck[cd];
      const card = cardMap[cd];
      if (!card) continue;

      if (card.race === "æ—§ç¥") {
        oldGodTypes.add(card.name);
        if (count > 1) {
          errors.push(`ãƒ»æ—§ç¥ã€Œ${card.name}ã€ã¯1æšã¾ã§ã§ã™`);
        }
      }
    }

    if (oldGodTypes.size > 1) {
      errors.push("æ—§ç¥ã‚«ãƒ¼ãƒ‰ã¯1ç¨®é¡ã¾ã§ã—ã‹å…¥ã‚Œã‚‰ã‚Œã¾ã›ã‚“");
    }

    return errors;
  }


//ãƒ¡ã‚¤ãƒ³ç¨®æ—åˆ¶é™
  function checkRaceLimit() {
    const errors = [];
    const raceSet = new Set();

    for (const cd in deck) {
      const card = cardMap[cd]; // â† parseCdAndCountã¯ä¸è¦ã§ã™
      if (!card) continue;
      raceSet.add(card.race);
    }

    const mainRaces = [...raceSet].filter(r => !["ã‚¤ãƒã‚»ãƒ³ãƒˆ", "æ—§ç¥"].includes(r));
    if (mainRaces.length > 1) {
      errors.push(`ä½¿ç”¨å¯èƒ½ãªç¨®æ—ã¯1ç¨®é¡ã§ã™ï¼ˆç¾åœ¨ï¼š${mainRaces.join("ãƒ»")}ï¼‰`);
    }

    return errors;
  }


//ã‚³ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
  function isDeckValidWithWarning() {
    const errors = [
      ...checkSameNameLimit(),
      ...checkOldGodLimit(),
      ...checkRaceLimit()
    ];

    if (errors.length > 0) {
      showToastWarning(errors);
      return false;
    }

    return true;
  }


  //ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
  function showToastWarning(messages) {
    const toast = document.getElementById("toast-warning");
    if (!toast) return;

    toast.innerHTML = "âš ï¸ãƒ‡ãƒƒã‚­åˆ¶é™é•å<br>" + messages.map(msg => "â—" + msg).join("<br>");
    toast.style.display = "block";

    setTimeout(() => {
      toast.style.display = "none";
    }, 4000);
  }


    // ğŸ“¤ ã‚³ãƒ¼ãƒ‰ç”Ÿæˆï¼ˆã‚³ãƒ”ãƒ¼ï¼‰
    document.getElementById("generate-code-btn").addEventListener("click", function () {
      const code = generateDeckCode(); // ãƒ‡ãƒƒã‚­ã‚³ãƒ¼ãƒ‰ç”Ÿæˆé–¢æ•°

      if (!code) {
        return; // â† ã‚³ãƒ”ãƒ¼ã‚‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚è¡Œã‚ãªã„
      }

      navigator.clipboard.writeText(code).then(() => {
        showCopyMessage();
      }).catch(err => {
        alert("ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ");
        hideCopyMessage(); // â† å¤±æ•—æ™‚ã«ãƒœã‚¿ãƒ³æ–‡è¨€ã‚’æˆ»ã™ï¼ˆä¸‹ã§å®šç¾©ï¼‰
      });
    });


    //ã‚³ãƒ¼ãƒ‰ç”Ÿæˆãƒœã‚¿ãƒ³å¤‰åŒ–
    function showCopyMessage() {
      const btn = document.getElementById("generate-code-btn");
      if (!btn) return;

      const original = btn.textContent;
      btn.textContent = "âœ… ç”Ÿæˆå®Œäº†";

      setTimeout(() => {
        btn.textContent = original;
      }, 1500); // 1.5ç§’å¾Œã«å…ƒã«æˆ»ã™
    }


    // ğŸ“¥ ã‚³ãƒ¼ãƒ‰èª­ã¿è¾¼ã¿ï¼ˆã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰ç›´æ¥ï¼‰
    document.getElementById("load-code-btn").addEventListener("click", async function () {
      try {
        const code = await navigator.clipboard.readText();
        if (!code) {
          // ä½•ã‚‚ã‚³ãƒ”ãƒ¼ã•ã‚Œã¦ã„ãªã„ã¨ãã¯é€šçŸ¥ã—ãªã„
          console.warn("âš ï¸ ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ãŒç©ºã§ã™");
          return;
        }

        const result = loadDeckFromCode(code.trim());

        if (result === "invalid") {
          alert("ãƒ‡ãƒƒã‚­ã‚³ãƒ¼ãƒ‰ãŒç„¡åŠ¹ã§ã™"); // ã“ã‚Œã¯è¡¨ç¤ºã—ãŸã„ãªã‚‰æ®‹ã™
        } else if (result === "rule_violation") {
          // åˆ¶é™é•åã® alert ã¯ loadDeckFromCode å´ã§å‡ºã™ã®ã§ã“ã“ã§ã¯ä½•ã‚‚ã—ãªã„
        } else if (result === "success") {
          alert("ãƒ‡ãƒƒã‚­ã‚’å¾©å…ƒã—ã¾ã—ãŸï¼");
        }
      } catch (err) {
        // âš ï¸ ã‚¨ãƒ©ãƒ¼ã¯ console ã«å‡ºã™ã ã‘ã§ã€alert ã¯ã—ãªã„
        console.error("ğŸ“› ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰èª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼:", err);
      }
    });


//ãƒ‡ãƒƒã‚­ã‚³ãƒ¼ãƒ‰ç”Ÿæˆå‡¦ç†
    function generateDeckCode() {

      if (Object.keys(deck).length === 0) return "";

      // ä½¿ç”¨ç¨®æ—ã‚’æŠ½å‡ºï¼ˆã‚¤ãƒã‚»ãƒ³ãƒˆãƒ»æ—§ç¥ã‚’é™¤ãï¼‰
      const validMainRaces = ["ãƒ‰ãƒ©ã‚´ãƒ³", "ã‚¢ãƒ³ãƒ‰ãƒ­ã‚¤ãƒ‰", "ã‚¨ãƒ¬ãƒ¡ãƒ³ã‚¿ãƒ«", "ãƒ«ãƒŸãƒŠã‚¹", "ã‚·ã‚§ã‚¤ãƒ‰"];
      const mainRace = Object.keys(deck)
        .map(cd => cardMap[cd]?.race)
        .find(r => validMainRaces.includes(r)) || "ãƒ‰ãƒ©ã‚´ãƒ³";

      const raceCodeMap = {
        "ãƒ‰ãƒ©ã‚´ãƒ³": 1,
        "ã‚¢ãƒ³ãƒ‰ãƒ­ã‚¤ãƒ‰": 2,
        "ã‚¨ãƒ¬ãƒ¡ãƒ³ã‚¿ãƒ«": 3,
        "ãƒ«ãƒŸãƒŠã‚¹": 4,
        "ã‚·ã‚§ã‚¤ãƒ‰": 5
      };
      const g = raceCodeMap[mainRace] || 1;

      // ã‚«ãƒ¼ãƒ‰æ§‹æˆï¼ˆ8æ¡ï¼š5æ¡cd + 3æ¡æšæ•°ï¼‰
      const cdList = Object.entries(deck).map(([cd, count]) => {
        const paddedCount = String(count).padStart(3, "0");
        return cd + paddedCount;
      });

      // ğŸ”¸ åˆ¶é™é•åãƒã‚§ãƒƒã‚¯
      if (!isDeckValidWithWarning()) {
        Object.keys(deck).forEach(k => delete deck[k]);
        return ;
      }

      // ä»£è¡¨ã‚«ãƒ¼ãƒ‰ï¼ˆcdã®æœ€åˆã‚’ä»£è¡¨ã¨ã™ã‚‹ï¼‰
      const m = representativeCd ? representativeCd.slice(0, 5) : "00000";


      // ãƒ‡ãƒƒã‚­åï¼ˆæœªå…¥åŠ›ãªã‚‰çœç•¥ï¼‰
      const name = document.getElementById("deck-name")?.value.trim();
      const obj = { g, cd: cdList.join(","), m: parseInt(m) };
      if (name) obj.n = name;

      return JSON.stringify(obj).replace(
        /"n":"(.*?)"/,
        (_, raw) => `"n":"${raw.replace(/./g, c => {
          const code = c.charCodeAt(0);
          return code < 128 ? c : "\\u" + code.toString(16).padStart(4, "0");
        })}"`
      );
    }


//ãƒ‡ãƒƒã‚­ã‚³ãƒ¼ãƒ‰èª­ã¿è¾¼ã¿å‡¦ç†
      function loadDeckFromCode(codeStr) {
        let obj;
        try {
          obj = JSON.parse(codeStr);
        } catch (e) {
          console.error("JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼:", e);
          return "invalid"; // â† ãƒ‘ãƒ¼ã‚¹å¤±æ•—
        }

        if (!obj || !obj.cd || typeof obj.cd !== "string") {
          console.warn("cdæƒ…å ±ãŒç„¡åŠ¹ã§ã™");
          return "invalid";
        }

        const newDeck = {};
        const parts = obj.cd.split(",");
        for (const part of parts) {
          if (!/^\d{8}$/.test(part)) {
            console.warn("å½¢å¼ä¸æ­£:", part);
            return "invalid";
          }

          const cd = part.slice(0, 5);
          const count = parseInt(part.slice(5, 8), 10);
          if (!cardMap[cd]) {
            console.warn("å­˜åœ¨ã—ãªã„ã‚«ãƒ¼ãƒ‰cd:", cd);
            continue;
          }

          newDeck[cd] = count;
        }

        // ãƒ‡ãƒƒã‚­æ›´æ–°
        Object.keys(deck).forEach(k => delete deck[k]);
        Object.assign(deck, newDeck);

        // ğŸ”¸ åˆ¶é™é•åãƒã‚§ãƒƒã‚¯
        if (!isDeckValidWithWarning()) {
          Object.keys(deck).forEach(k => delete deck[k]);
          return;
        }

        // ä»£è¡¨ã‚«ãƒ¼ãƒ‰ï¼ˆmï¼‰ã®åæ˜ 
        if (obj.m) {
          const repCdPrefix = String(obj.m).padStart(5, "0");
          for (const cd of Object.keys(deck)) {
            if (cd.startsWith(repCdPrefix)) {
              representativeCd = cd;
              break;
            }
          }
        }

        // ãƒ‡ãƒƒã‚­åã®è¡¨ç¤ºã‚‚æ›´æ–°
        if (obj.n && document.getElementById("deck-name")) {
          document.getElementById("deck-name").value = obj.n;
        }

        updateDeck();
        updateCardDisabling();
        renderDeckList();
        updateDeckSummaryDisplay();
        return "success";
      }


//ãƒ‡ãƒƒã‚­ä¸€æ™‚ä¿å­˜ãƒœã‚¿ãƒ³
  function saveDeckToLocalStorage() {
    // ğŸ”¸ åˆ¶é™é•åãƒã‚§ãƒƒã‚¯
    if (!isDeckValidWithWarning()) {
      Object.keys(deck).forEach(k => delete deck[k]);
      return ;
    }
    // ãƒ‡ãƒƒã‚­å
    const deckNameInput = document.getElementById("deck-name");
    const deckName = deckNameInput ? deckNameInput.value.trim() : "åç§°æœªè¨­å®š";

    // ä½¿ç”¨ç¨®æ—ï¼ˆæ—§ç¥ãƒ»ã‚¤ãƒã‚»ãƒ³ãƒˆä»¥å¤–ã‹ã‚‰æŠ½å‡ºï¼‰
    const validMainRaces = ["ãƒ‰ãƒ©ã‚´ãƒ³", "ã‚¢ãƒ³ãƒ‰ãƒ­ã‚¤ãƒ‰", "ã‚¨ãƒ¬ãƒ¡ãƒ³ã‚¿ãƒ«", "ãƒ«ãƒŸãƒŠã‚¹", "ã‚·ã‚§ã‚¤ãƒ‰"];
    const mainRace = Object.keys(deck)
      .map(cd => cardMap[cd]?.race)
      .find(r => validMainRaces.includes(r)) || "ãƒ‰ãƒ©ã‚´ãƒ³";

    const raceCodeMap = {
      "ãƒ‰ãƒ©ã‚´ãƒ³": 1,
      "ã‚¢ãƒ³ãƒ‰ãƒ­ã‚¤ãƒ‰": 2,
      "ã‚¨ãƒ¬ãƒ¡ãƒ³ã‚¿ãƒ«": 3,
      "ãƒ«ãƒŸãƒŠã‚¹": 4,
      "ã‚·ã‚§ã‚¤ãƒ‰": 5
    };
    const g = raceCodeMap[mainRace] || 1;

    // ä»£è¡¨ã‚«ãƒ¼ãƒ‰ï¼ˆæœ€åˆã®ã‚«ãƒ¼ãƒ‰ã‚’ä»®ã«ä½¿ã†ã€‚åˆ¥ã§è¨­å®šã—ã¦ã„ã‚‹å ´åˆã¯ representativeCd ã‚’ä½¿ç”¨ï¼‰
    const m = representativeCd || Object.keys(deck)[0] || "10001";

    // ä¿å­˜ãƒ‡ãƒ¼ã‚¿æ§‹é€ 
    const newDeck = {
      name: deckName,
      g,
      m,
      cardCounts: { ...deck }
    };

    const MAX_SAVED_DECKS = 20;

    // æ—¢å­˜ã®ä¿å­˜ãƒªã‚¹ãƒˆã‚’å–å¾—
    const savedList = JSON.parse(localStorage.getItem("savedDecks") || "[]");

    // åŒåãƒ‡ãƒƒã‚­ä»¥å¤–â†’è¿½åŠ 
    const existingIndex = savedList.findIndex(d => d.name === deckName);

    // âœ… ä¸Šæ›¸ãç¢ºèª
    if (existingIndex !== -1) {
      const confirmed = confirm(`åŒã˜åå‰ã®ãƒ‡ãƒƒã‚­ã€Œ${deckName}ã€ãŒã™ã§ã«å­˜åœ¨ã—ã¾ã™ã€‚ä¸Šæ›¸ãã—ã¾ã™ã‹ï¼Ÿ`);
      if (!confirmed) {
        alert("ä¿å­˜ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ");
        return;
      }
      savedList[existingIndex] = newDeck;
    } else {
        // âœ… ä¸Šé™ãƒã‚§ãƒƒã‚¯ï¼ˆæ–°è¦ä¿å­˜ã®ã¿ï¼‰
      if (savedList.length >= MAX_SAVED_DECKS) {
        alert("ä¿å­˜ã§ãã‚‹ãƒ‡ãƒƒã‚­ã¯æœ€å¤§20ä»¶ã¾ã§ã§ã™ã€‚ä¸è¦ãªãƒ‡ãƒƒã‚­ã‚’å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚");
        return;
      }

      savedList.push(newDeck);
    }

    // ä¿å­˜ã—ã¦æ›´æ–°
    localStorage.setItem("savedDecks", JSON.stringify(savedList));
    updateSavedDeckList();
    alert("ãƒ‡ãƒƒã‚­ã‚’ä¿å­˜ã—ã¾ã—ãŸ");

  }


//ãƒ‡ãƒƒã‚­ãƒªã‚»ãƒƒãƒˆ
  document.getElementById("resetDeckButton").addEventListener("click", () => {
    if (confirm("æœ¬å½“ã«ãƒ‡ãƒƒã‚­ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) {
      // ğŸ”‘ ãƒ‡ãƒƒã‚­ãƒ‡ãƒ¼ã‚¿ã‚’ç©ºã«
      for (const key in deck) {
        delete deck[key];
      }

      // ğŸ”‘ æ›´æ–°
      updateDeck();       // ãƒ‡ãƒƒã‚­ãƒãƒ¼ï¼†ç¨®æ—ãªã©
      renderDeckList();   // ãƒ‡ãƒƒã‚­è©³ç´°ãƒªã‚¹ãƒˆ
      // ğŸ”‘ ãƒ‡ãƒƒã‚­åã‚’ãƒªã‚»ãƒƒãƒˆ
      document.getElementById("deck-name").value = "";

      // ğŸ”‘ representativeCd ã‚’åˆæœŸåŒ–ã—ã¦è¡¨ç¤ºæ›´æ–°
      representativeCd = "";
      updateDeckSummaryDisplay();
    }
  });



//ä¸€æ™‚ä¿å­˜ãƒ‡ãƒƒã‚­ãƒªã‚¹ãƒˆç¢ºèª
    function updateSavedDeckList() {
      const container = document.getElementById("savedDeckList");
      const counter = document.getElementById("savedDeckCount");
      container.innerHTML = "";

      const multiSaved = JSON.parse(localStorage.getItem("savedDecks") || "[]");

        // âœ… ä»¶æ•°è¡¨ç¤ºï¼ˆ20ä¸Šé™ï¼‰
      if (counter) {
        counter.textContent = `ä¿å­˜ãƒ‡ãƒƒã‚­æ•°ï¼š${multiSaved.length} / 20`;
      }
      // âœ… è¤‡æ•°ä¿å­˜ãƒ‡ãƒƒã‚­ãŒã‚ã‚‹å ´åˆ
      if (multiSaved.length > 0) {
        multiSaved.forEach((deckData, index) => {
          // âœ… ä¿å­˜æ—¥æ™‚ãŒãªã„å ´åˆã¯ä½œã‚‹ï¼ˆå¤ã„ãƒ‡ãƒ¼ã‚¿ç”¨ï¼‰
          if (!deckData.date) {
            const today = new Date();
            const yyyy = today.getFullYear();
            const mm = String(today.getMonth() + 1).padStart(2, '0');
            const dd = String(today.getDate()).padStart(2, '0');
            deckData.date = `${yyyy}/${mm}/${dd}`;
          }

          // âœ… generateDeckLayout ã«æ¸¡ã™
          const html = generateDeckLayout(deckData, index);
          container.insertAdjacentHTML("beforeend", html);
        });
        return;
      }


      // ğŸ” è¤‡æ•°ä¿å­˜ãŒãªã‘ã‚Œã°ã€æ—§å¼ï¼ˆtempDeckï¼‰ã‚’ä½¿ã†
      const singleSaved = localStorage.getItem("tempDeck");
      if (singleSaved) {
        try {
          const parsed = JSON.parse(singleSaved);
          if (parsed.cardCounts) {
            container.innerHTML = generateDeckLayout(parsed, 0);

            // âœ… æ—§å¼ä¿å­˜ã«ã‚‚ä»¶æ•°è¡¨ç¤ºï¼ˆ1ä»¶æ‰±ã„ï¼‰
            if (counter) {
              counter.textContent = `ä¿å­˜ãƒ‡ãƒƒã‚­æ•°ï¼š1 / 20`;
            }
            return;
          }
        } catch (e) {
          container.innerHTML = "<p style='color:red;'>ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</p>";
          return;
        }
      }

      // ğŸ†˜ ã©ã¡ã‚‰ã‚‚ãªã„å ´åˆã¯ä»®ãƒ‡ãƒƒã‚­ã‚’è¡¨ç¤º
      container.innerHTML = generateDeckLayout(null);
      if (counter) {
        counter.textContent = `ä¿å­˜ãƒ‡ãƒƒã‚­æ•°ï¼š0 / 20`;
      }
    }


//ä¿å­˜ãƒ‡ãƒƒã‚­è¡¨ç¤º
  function generateDeckLayout(deckData, index = null) {
    let cardImg = "img/10001.webp";
    let deckName = "ãƒ‡ãƒƒã‚­ä¸€æ™‚ä¿å­˜ï¼ˆè¤‡æ•°å¯ï¼‰";
    let race = "ãƒªãƒ¼ãƒ€ãƒ¼ç¨®æ—è¡¨ç¤º";
    let count = "ãƒ‡ãƒƒã‚­æšæ•°";
    let typeCount = "ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼ï¼šğŸ”µã‚¢ã‚¿ãƒƒã‚«ãƒ¼ï¼šğŸŸ£ãƒ–ãƒ­ãƒƒã‚«ãƒ¼ï¼šâšªï¸";
    let savedDate = ""; // âœ… ä¿å­˜æ—¥æ™‚ã®åˆæœŸå€¤

    if (deckData && deckData.cardCounts) {
      // âœ… ãƒ‡ãƒƒã‚­æšæ•°ãƒ»ã‚¿ã‚¤ãƒ—æ•°ã‚’è¨ˆç®—
      let total = 0, charge = 0, attack = 0, block = 0;
      for (const cd in deckData.cardCounts) {
        const n = deckData.cardCounts[cd];
        total += n;
        const card = cards.find(c => c.cd === cd);
        if (card) {
          if (card.type === "ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼") charge += n;
          if (card.type === "ã‚¢ã‚¿ãƒƒã‚«ãƒ¼") attack += n;
          if (card.type === "ãƒ–ãƒ­ãƒƒã‚«ãƒ¼") block += n;
        }
      }
      count = total + "/30~40";
      typeCount = `ğŸ”µ${charge}ğŸŸ£${attack}âšªï¸${block}`;
      deckName = deckData.name || "åç§°æœªè¨­å®š";
      race = getMainTribe(deckData.g);

      // âœ… ä»£è¡¨ã‚«ãƒ¼ãƒ‰ç”»åƒ
      if (deckData.m) {
        cardImg = "img/" + String(deckData.m) + ".webp";
      }

      // âœ… ä¿å­˜æ—¥æ™‚ãŒã‚ã‚Œã°è¨­å®šï¼ˆç„¡ã‘ã‚Œã°ç©ºï¼‰
      savedDate = deckData.date ? deckData.date : "";
    }

    // âœ… èª­ã¿è¾¼ã¿ãƒ»å‰Šé™¤ãƒœã‚¿ãƒ³ï¼ˆè¤‡æ•°ã‹å˜ä¸€ã‹ï¼‰
    const loadBtn = index != null
      ? `<button onclick="loadDeckFromIndex(${index})">ğŸ”„ èª­ã¿è¾¼ã‚€</button>`
      : `<button onclick="loadDeckFromSaved()">ğŸ”„ èª­ã¿è¾¼ã‚€</button>`;

    const deleteBtn = index != null
      ? `<button onclick="deleteDeckFromIndex(${index})">ğŸ—‘ å‰Šé™¤</button>`
      : `<button onclick="clearSavedDeck()">ğŸ—‘ å‰Šé™¤</button>`;

    // âœ… ä¿å­˜æ—¥æ™‚ã‚’å«ã‚€HTMLã‚’è¿”ã™
    return `
    <div class="saved-deck-item">
      <img src="${cardImg}" alt="ä»£è¡¨ã‚«ãƒ¼ãƒ‰" />
      <div class="saved-deck-info">
        <div class="row">
          <strong>${deckName}</strong>
          <span>ä½¿ç”¨ç¨®æ—ï¼š${race}</span>
        </div>
        <div class="row">
          <span>${count}</span>
          <span>${typeCount}</span>
        </div>
        ${savedDate
        ? `<div class="row"><small>ä¿å­˜æ—¥æ™‚: ${savedDate}</small></div>`
        : ""
      }
      </div>
      <div class="deck-buttons">
        ${loadBtn}
        ${deleteBtn}
      </div>
    </div>
  `;
  }


//ãƒ¡ã‚¤ãƒ³ç¨®æ—åˆ¤æ–­
        function getMainTribe(g) {
          const tribeMap = {
            1: "ãƒ‰ãƒ©ã‚´ãƒ³",
            2: "ã‚¢ãƒ³ãƒ‰ãƒ­ã‚¤ãƒ‰",
            3: "ã‚¨ãƒ¬ãƒ¡ãƒ³ã‚¿ãƒ«",
            4: "ãƒ«ãƒŸãƒŠã‚¹",
            5: "ã‚·ã‚§ã‚¤ãƒ‰"
          };
          return tribeMap[g] || "ï¼Ÿ";
        }


//ä¸€æ™‚ä¿å­˜ãƒ‡ãƒƒã‚­å˜ä½“
    function loadDeckFromSaved() {
      const saved = localStorage.getItem("tempDeck");
      if (!saved) return alert("ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒƒã‚­ãŒã‚ã‚Šã¾ã›ã‚“");

      try {
        const parsed = JSON.parse(saved);

        const deckNameInput = document.getElementById("deck-name");
        if (deckNameInput) {
          deckNameInput.value = parsed.name || "";
        }

        // ã“ã“ãŒä¿®æ­£ãƒã‚¤ãƒ³ãƒˆ
        for (const key in deck) {
          delete deck[key];
        }
        Object.assign(deck, parsed.cardCounts);

        updateDeck();
        updateCardDisabling();
        renderDeckList()
        updateDeckSummaryDisplay();

        alert("ä¸€æ™‚ä¿å­˜ã—ãŸãƒ‡ãƒƒã‚­ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ");

      } catch (e) {
        alert("ãƒ‡ãƒƒã‚­ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ");
        console.error(e);
      }
    }

//ä¸€æ™‚ä¿å­˜ãƒ‡ãƒƒã‚­è¤‡æ•°
      function loadDeckFromIndex(index) {
        const savedList = JSON.parse(localStorage.getItem("savedDecks") || "[]");
        const data = savedList[index];
        if (!data) return;

        const nameInput = document.getElementById("deck-name");
        if (nameInput) nameInput.value = data.name || "";

        for (const key in deck) delete deck[key];
        Object.assign(deck, data.cardCounts);

        updateDeck();
        updateCardDisabling();
        renderDeckList();
        updateDeckSummaryDisplay();
        alert("ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒƒã‚­ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ");
      }


//ä¸€æ™‚ä¿å­˜ãƒ‡ãƒƒã‚­å‰Šé™¤ï¼ˆå˜ä½“ï¼‰
    function clearSavedDeck() {
      localStorage.removeItem("tempDeck");
      updateSavedDeckList();
      alert("ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒƒã‚­ã‚’å‰Šé™¤ã—ã¾ã—ãŸ");
    }


//ä¸€æ™‚ä¿å­˜ãƒ‡ãƒƒã‚­å‰Šé™¤ï¼ˆè¤‡æ•°ï¼‰
  function deleteDeckFromIndex(index) {
    const savedList = JSON.parse(localStorage.getItem("savedDecks") || "[]");
    savedList.splice(index, 1);
    localStorage.setItem("savedDecks", JSON.stringify(savedList));
    updateSavedDeckList(); // ä¸€è¦§ã‚’æ›´æ–°
  }


//ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆæ™‚ä¸€æ™‚ä¿å­˜ãƒªã‚¹ãƒˆæ›´æ–°
    document.getElementById("tab-edit")?.addEventListener("click", () => {
      updateSavedDeckList();
    });


  //é¾å¹´ãƒ¢ãƒ¼ãƒ‰è¡¨ç¤º
  const searchInput = document.getElementById('keyword'); // æ¤œç´¢æ¬„ã®ID
  const dragonButton = document.getElementById('dragon-mode-btn'); // é¾å¹´ãƒœã‚¿ãƒ³ã®ID

  searchInput.addEventListener('input', () => {
    const keyword = searchInput.value.trim();
    if (keyword.includes('é¾å¹´')) {
      dragonButton.style.display = 'inline-block'; // ãƒœã‚¿ãƒ³è¡¨ç¤º
    } else {
      dragonButton.style.display = 'none'; // éè¡¨ç¤º
    }
  });


//æ‰€æŒã‚«ãƒ¼ãƒ‰åæ˜ ãƒœã‚¿ãƒ³
  function toggleOwned() {
    if (!isOwnedReflected) {
      const confirmed = window.confirm("æ‰€æŒã‚«ãƒ¼ãƒ‰ã‚’åæ˜ ã—ã¾ã™ã‹ï¼Ÿ");
      if (confirmed) {
        isOwnedReflected = true;
        document.getElementById("toggleOwnedBtn").innerText = "æ‰€æŒã‚«ãƒ¼ãƒ‰åæ˜ ä¸­";
        // ã“ã“ã§æ‰€æŒç‡åæ˜ å‡¦ç†ã‚’å‘¼ã¶äºˆå®š
      }
    } else {
      // ã‚‚ã—OFFã«æˆ»ã™ä»•æ§˜ãŒã‚ã‚Œã°
      isOwnedReflected = false;
      document.getElementById("toggleOwnedBtn").innerText = "æ‰€æŒã‚«ãƒ¼ãƒ‰æœªåæ˜ ";
      // ã“ã“ã§æ‰€æŒç‡æœªåæ˜ çŠ¶æ…‹ã«æˆ»ã™å‡¦ç†ã‚’å‘¼ã¶
    }
  }
</script>


</body>
</html>